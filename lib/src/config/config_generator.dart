// lib/src/config/config_generator.dart

import 'dart:io';

import 'package:path/path.dart' as path;

// Import Configuration to access defaults
import 'configuration.dart';

/// Handles the generation of a default configuration file (`llmifierrc.yaml`).
class ConfigGenerator {
  static const String _configFileName = 'llmifierrc.yaml';

  /// Generates the default `llmifierrc.yaml` file in the specified [projectPath].
  ///
  /// Checks if the file already exists to prevent accidental overwrites.
  /// Returns `true` if the file was successfully created, `false` otherwise
  /// (e.g., if the file already exists or an error occurred).
  Future<bool> generateDefaultConfig(String projectPath, {bool verbose = false}) async {
    final configFilePath = path.join(projectPath, _configFileName);
    final configFile = File(configFilePath);

    if (verbose) {
      print('Attempting to generate default config at: $configFilePath');
    }

    // Check if the file already exists
    if (await configFile.exists()) {
      print('Configuration file already exists at: $configFilePath');
      print('Skipping generation to avoid overwriting.');
      return false; // Indicate skipped/failed due to existence
    }

    // Ensure the target directory exists
    try {
      final parentDir = configFile.parent;
      if (!await parentDir.exists()) {
        if (verbose) {
          print('Creating directory: ${parentDir.path}');
        }
        await parentDir.create(recursive: true);
      }
    } on FileSystemException catch (e) {
      stderr.writeln('Error: Could not create directory for config file: $e');
      return false;
    }

    // --- Generate the default YAML content dynamically ---
    final yamlContent = _buildDefaultYamlContent();

    // Write the file
    try {
      await configFile.writeAsString(yamlContent);
      print('Successfully generated default configuration file at: $configFilePath');
      return true; // Indicate success
    } on FileSystemException catch (e) {
      stderr.writeln('Error: Could not write configuration file: $e');
      return false; // Indicate failure
    } catch (e) {
      stderr.writeln('An unexpected error occurred during config file generation: $e');
      return false; // Indicate failure
    }
  }

  /// Builds the string content for the default `llmifierrc.yaml` file
  /// based on the values defined in [Configuration.defaults].
  String _buildDefaultYamlContent() {
    // Get the defaults which now contain the effective patterns
    final defaults = Configuration.defaults();
    final buffer = StringBuffer();

    // Helper function to format YAML lists
    String formatYamlList(List<String> items, int indent) {
      if (items.isEmpty) {
        return '';
      }
      final indentString = ' ' * indent;
      // Quote items, especially those starting with '.' or containing '*'
      return items.map((item) => "$indentString- \"${item.replaceAll('"', '\\"')}\"").join('\n');
    }

    // Header Comment
    buffer.writeln('# llmifier Configuration File (`llmifierrc.yaml`)');
    buffer.writeln('# Generated by `llmifier --init`. Customize as needed.');
    buffer.writeln('# Documentation: https://github.com/PhilippHGerber/llmifier');
    buffer.writeln();

    // Basic Settings Section
    buffer.writeln('# --- Basic Settings ---');
    buffer.writeln();
    buffer.writeln('# Optional: Define the output file name. Defaults to "${defaults.outputPath}".');
    buffer.writeln('# output: "${defaults.outputPath}"');
    buffer.writeln();

    // projectType
    buffer.writeln('# Project type influences default file patterns and ordering priorities.');
    buffer.writeln('# Allowed values: "dart" for Flutter/Dart projects.');
    buffer.writeln('projectType: "${defaults.projectType.name}"');
    buffer.writeln();

    // mode
    buffer.writeln('# Extraction mode determines what content is included.');
    buffer.writeln('# - "full": Includes the complete content of matched files.');
    buffer.writeln('# - "api": Includes only public APIs (classes, functions, variables)');
    buffer.writeln('#          with their documentation comments for Dart/Flutter files.');
    buffer.writeln('mode: "${defaults.mode.name}"');
    buffer.writeln();
    buffer.writeln('# Optional: Enable verbose logging.');
    buffer.writeln('# verbose: ${defaults.verbose}');
    buffer.writeln();

    // File Inclusion/Exclusion Section
    buffer.writeln('# --- File Inclusion/Exclusion Patterns ---');
    buffer.writeln('# NOTE: Default patterns are structured to handle root and nested files/dirs.');
    buffer.writeln('# See documentation or comments below for pattern explanations.');

    buffer.writeln();
    buffer.writeln('# Files/Dirs to include:');
    buffer.writeln('# - "**<file>" includes file recursively (root + nested)');
    buffer.writeln('# - "**<dir>/**.ext" includes .ext files in dir recursively (root + nested)');
    buffer.writeln('include:');
    // Directly use patterns from defaults
    buffer.writeln(formatYamlList(defaults.includePatterns, 2));
    buffer.writeln();
    buffer.writeln('# Files/Dirs to exclude (override includes):');
    buffer.writeln('# - "**<dir>" excludes dir recursively (root + nested, no trailing /)');
    buffer.writeln('# - "*.ext" excludes root .ext files');
    buffer.writeln('# - "**/*.ext" excludes nested .ext files');
    buffer.writeln('# - ".*" excludes root hidden files/dirs');
    buffer.writeln('# - "**/.*" excludes nested hidden files/dirs');
    buffer.writeln('exclude:');
    // Directly use patterns from defaults
    buffer.writeln(formatYamlList(defaults.excludePatterns, 2));
    buffer.writeln();
    buffer.writeln('# Add project-specific excludes below:');
    buffer.writeln('# - "**specific_package_to_ignore"');

    return buffer.toString();
  }
}
