import 'dart:io';

import 'package:path/path.dart' as path;

import 'configuration.dart';

/// Handles the generation of a default configuration file (`llmifierrc.yaml`).
class ConfigGenerator {
  static const String _configFileName = 'llmifierrc.yaml';

  /// Generates the default `llmifierrc.yaml` file in the specified [projectPath].
  ///
  /// Checks if the file already exists to prevent accidental overwrites.
  /// Returns `true` if the file was successfully created, `false` otherwise
  /// (e.g., if the file already exists or an error occurred).
  Future<bool> generateDefaultConfig(
    String projectPath, {
    bool verbose = false,
  }) async {
    final configFilePath = path.join(projectPath, _configFileName);
    final configFile = File(configFilePath);

    if (verbose) {
      print('Attempting to generate default config at: $configFilePath');
    }

    if (await configFile.exists()) {
      print('Configuration file already exists at: $configFilePath');
      print('Skipping generation to avoid overwriting.');
      return false;
    }

    try {
      final parentDir = configFile.parent;
      if (!await parentDir.exists()) {
        if (verbose) {
          print('Creating directory: ${parentDir.path}');
        }
        await parentDir.create(recursive: true);
      }
    } on FileSystemException catch (e) {
      stderr.writeln('Error: Could not create directory for config file: $e');
      return false;
    }

    final yamlContent = _buildDefaultYamlContent();

    try {
      await configFile.writeAsString(yamlContent);
      print('Generated default configuration file at: $configFilePath');
      return true;
    } on FileSystemException catch (e) {
      stderr.writeln('Error: Could not write configuration file: $e');
      return false;
    } catch (e) {
      stderr.writeln('An unexpected error occurred during '
          'config file generation: $e');
      return false;
    }
  }

  /// Builds the string content for the default `llmifierrc.yaml` file
  /// based on the values defined in [Configuration.defaults].
  String _buildDefaultYamlContent() {
    final defaults = Configuration.defaults();
    final buffer = StringBuffer();

    // Helper to format YAML lists, quoting items as needed.
    String formatYamlList(
      List<String> items,
      int indent, {
      bool quoteItems = true,
    }) {
      if (items.isEmpty) return '';
      final indentString = ' ' * indent;
      return items
          .map(
            (item) =>
                "$indentString- ${quoteItems ? '"${item.replaceAll('"', '\\"')}"' : item}",
          )
          .join('\n');
    }

    // Header Comment
    buffer.writeln('# llmifier Configuration File (`llmifierrc.yaml`)');
    buffer.writeln('# Generated by `llmifier --init`. Customize as needed.');
    buffer.writeln('# Full documentation: '
        'https://github.com/PhilippHGerber/llmifier');
    buffer.writeln();

    // Basic Settings Section
    buffer.writeln('# --- Basic Settings ---');
    buffer.writeln();
    buffer.writeln('# Output file path. Default: "${defaults.outputPath}"');
    buffer.writeln('# output: "${defaults.outputPath}"');
    buffer.writeln();

    buffer.writeln('# Project type '
        '(influences default include/exclude and fileOrdering).');
    buffer
        .writeln('# Allowed: "dart". Default: "${defaults.projectType.name}"');
    buffer.writeln('projectType: "${defaults.projectType.name}"');
    buffer.writeln();
    buffer.writeln('# Extraction mode: '
        '"full" (all content) or "api" (public API for Dart).');
    buffer.writeln('# Default: "${defaults.mode.name}"');
    buffer.writeln('mode: "${defaults.mode.name}"');
    buffer.writeln();
    buffer.writeln('# Enable verbose logging. Default: ${defaults.verbose}');
    buffer.writeln('# verbose: true');
    buffer.writeln();

    // File Inclusion/Exclusion Section
    buffer.writeln('# --- Global File Inclusion/Exclusion (Glob Patterns) ---');
    buffer.writeln('# These apply BEFORE file ordering. '
        'Files excluded here will not be processed.');
    buffer.writeln();
    buffer.writeln('# Files/Directories to include:');
    buffer.writeln('include:');
    buffer.writeln(formatYamlList(defaults.includePatterns, 2));
    buffer.writeln();
    buffer.writeln('# Files/Directories to exclude (overrides includes):');
    buffer.writeln('exclude:');
    buffer.writeln(formatYamlList(defaults.excludePatterns, 2));
    buffer.writeln();
    buffer.writeln('# Add project-specific global excludes below:');
    buffer.writeln('# - "**/specific_tool_generated_output/"');
    buffer.writeln();

    // File Ordering Section - NEU
    buffer.writeln('# --- File Ordering Strategy ---');
    buffer.writeln('# Defines how included files are grouped '
        'and ordered in the output.');
    buffer.writeln('# Files are assigned to the *first* '
        'matching group in this list.');
    buffer.writeln('fileOrdering:');
    buffer.writeln('  groups:');
    for (final group in defaults.fileOrderingGroups) {
      final groupIndent = '    '; // Indent for group properties
      final listIndent = '      '; // Indent for list items

      buffer.writeln('    - name: "${group.name.replaceAll('"', '\\"')}"');
      buffer.writeln('$groupIndent  patterns:');
      buffer.writeln(formatYamlList(group.patterns, listIndent.length));

      if (group.order.isNotEmpty) {
        buffer.writeln('$groupIndent  order:');
        buffer.writeln(formatYamlList(group.order, listIndent.length));
      }
      // Always write sortBy, even if it's the default, for clarity.
      buffer.writeln('$groupIndent  sortBy: "${group.sortBy.name}"');
      buffer.writeln(); // Blank line after each group for readability
    }
    buffer.writeln('# Example of a custom group:');
    buffer.writeln('#    - name: "Important Configs First"');
    buffer.writeln('#      patterns: '
        '["**/my_critical_config.json", '
        '"**/another_settings.yaml"]');
    buffer.writeln('#      order: ["my_critical_config.json"]');
    buffer.writeln('#      sortBy: "alphabetical"');
    buffer.writeln();
    buffer.writeln('# The last group can be a "catch-all" if desired:');
    buffer.writeln('#    - name: "Other Remaining Files"');
    buffer.writeln('#      patterns: '
        '["**/*"] # Matches anything not caught by earlier groups');
    buffer.writeln('#      sortBy: "alphabetical"');

    return buffer.toString();
  }
}
