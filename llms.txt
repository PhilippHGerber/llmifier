# Project Documentation: llmifier v0.2.2

Generated by llmifier on: 2025-05-11T09:25:22
Extraction Mode: full
Project Type: dart

---

<!-- BEGIN FILE: [v0.2.2] README.md -->
# llmifier ‚Ä¢ [![pub package](https://img.shields.io/pub/v/llmifier.svg)](https://pub.dev/packages/llmifier) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

**Transform your Dart & Flutter projects into optimized LLM context ‚Äì get better code generation, more insightful reviews, and precise answers.**

<p align="center">
  <img src="https://raw.githubusercontent.com/PhilippHGerber/llmifier/main/images/llmifier-flow.webp" alt="llmifier workflow" width="600">
</p>

## What llmifier Does

llmifier extracts and organizes your Dart/Flutter code into a single file that LLMs can understand perfectly:

- ‚úÖ **Smart Context Compression** - Feed entire projects to LLMs, even with limited context windows
- ‚úÖ **Semantic Organization** - Files ordered logically (Docs ‚Üí Config ‚Üí API ‚Üí Tests) for optimal comprehension
- ‚úÖ **Version Tracking** - Each file tagged with package version for accurate historical analysis
- ‚úÖ **API Focus** - Extract either full code or just public API surface with documentation
- ‚úÖ **Developer-Friendly** - Simple CLI workflow integrates with your existing development process

## Quick Start

```bash
# Install globally
dart pub global activate llmifier

# Run in your project directory
llmifier

# That's it! Find your LLM-ready project in llms.txt
```

## Example: From Fragmented Files to LLM-Ready Context

```
üìÅ Your Flutter Project      ‚û°Ô∏è   üìÑ Single LLM-Optimized File
‚îú‚îÄ‚îÄ README.md                     <!-- BEGIN FILE: [v1.2.3] README.md -->
‚îú‚îÄ‚îÄ pubspec.yaml                  # Project documentation...
‚îú‚îÄ‚îÄ lib/                          <!-- END FILE: [v1.2.3] README.md -->
‚îÇ   ‚îú‚îÄ‚îÄ main.dart
‚îÇ   ‚îî‚îÄ‚îÄ src/                      <!-- BEGIN FILE: [v1.2.3] pubspec.yaml -->
‚îÇ       ‚îú‚îÄ‚îÄ models.dart           # Package configuration...
‚îÇ       ‚îî‚îÄ‚îÄ utils.dart            <!-- END FILE: [v1.2.3] pubspec.yaml -->
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ widget_test.dart          <!-- BEGIN FILE: [v1.2.3] lib/main.dart -->
                                  # Main app code...
                                  <!-- END FILE: [v1.2.3] lib/main.dart -->

                                  <!-- BEGIN FILE: [v1.2.3] lib/src/models.dart -->
                                  # Model definitions...
                                  <!-- END FILE: [v1.2.3] lib/src/models.dart -->
```

## Command Options

```bash
# Generate API-only output with cleaner context
llmifier -m api -o llms-api.txt

# Process a specific project directory
llmifier -p path/to/your/project

# Generate a default config file
llmifier -i

# See all options
llmifier -h
```

## How Developers Use llmifier

### For Code Generation

Structure your whole project context to get precise, relevant code generation that fits your architecture and styles:

```
# Create feature with project context
1. Run: llmifier
2. Paste llms.txt into your LLM
3. Prompt: "Add a user authentication feature matching our existing architecture"
```

### For Code Reviews

Get meaningful, holistic code reviews that understand your entire project:

```
# Compare versions for insightful review
1. Run: llmifier on version 1.0
2. Run: llmifier on version 1.1
3. Prompt: "What architectural changes were made between these versions?"
```

### For Documentation

Generate comprehensive documentation based on actual code structure:

```
# Create targeted API documentation
1. Run: llmifier -m api
2. Prompt: "Create developer documentation for our public API"
```

### For Onboarding

Help new team members (or your LLM assistant) quickly understand your codebase:

```
# Create onboarding guide
1. Run: llmifier
2. Prompt: "Explain the architecture and key components of this project"
```

## Customizing Extraction

Create a `llmifierrc.yaml` in your project root (or generate one with `llmifier -i`):

```yaml
# Basic configuration
mode: api  # 'full' or 'api'
output: project-context.txt

# File selection patterns
include:
  - "**README.md"
  - "**lib/**.dart"
  - "**test/integration/**.dart"

exclude:
  - "**build"
  - "**.g.dart"
```

## Contributing

Contributions are welcome! Please feel free to open an issue or submit a pull request on the [GitHub repository](https://github.com/PhilippHGerber/llmifier).

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

<!-- END FILE: [v0.2.2] README.md -->

<!-- BEGIN FILE: [v0.2.2] CHANGELOG.md -->
# CHANGELOG

## 0.2.1

2025-05-10

### Bug Fixes

- **API Extraction:** Improved the accuracy and completeness of API signature extraction.
- **File Ordering:** Corrected an issue where the `order` directive within file group configurations was not being properly applied to root-level files.

## 0.2.0

### Features

- **File Organization:** Added packages group and updated patterns for better file organization
- **Configuration:** Enhanced configuration loading and file ordering mechanisms
- **Documentation:** Enhanced README with additional usage scenarios for:

## 0.1.0

### Features

- **Configuration:** Enhanced configuration loading and file ordering mechanisms

### Refactoring

- Improved code readability through consistent formatting

## 0.0.3

- Initial version.

<!-- END FILE: [v0.2.2] CHANGELOG.md -->

<!-- BEGIN FILE: [v0.2.2] LICENSE -->
MIT License

Copyright (c) 2025 Philipp H. Gerber

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

<!-- END FILE: [v0.2.2] LICENSE -->

<!-- BEGIN FILE: [v0.2.2] pubspec.yaml -->
name: llmifier
description: >-
  A CLI tool to extract, structure, and consolidate Dart & Flutter
  project files into a single, LLM-friendly context.
version: 0.2.2
homepage: https://github.com/PhilippHGerber/llmifier
repository: https://github.com/PhilippHGerber/llmifier
issue_tracker: https://github.com/PhilippHGerber/llmifier/issues

topics:
  - llm
  - cli

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  analyzer: ^7.4.4
  args: ^2.4.0
  collection: ^1.19.1
  glob: ^2.1.3
  intl: ^0.20.2
  path: ^1.8.3
  meta: ^1.16.0
  yaml: ^3.1.3

dev_dependencies:
  build_runner: ^2.4.15
  build_version: ^2.1.1
  lints: ^5.0.0
  test: ^1.24.0

executables:
  llmifier: main

platforms:
  linux:
  macos:
  windows:

license: MIT

<!-- END FILE: [v0.2.2] pubspec.yaml -->

<!-- BEGIN FILE: [v0.2.2] analysis_options.yaml -->
# This file configures the static analysis results for your project (errors,
# warnings, and lints).
#
# This enables the 'recommended' set of lints from `package:lints`.
# This set helps identify many issues that may lead to problems when running
# or consuming Dart code, and enforces writing Dart using a single, idiomatic
# style and format.
#
# If you want a smaller set of lints you can change this to specify
# 'package:lints/core.yaml'. These are just the most critical lints
# (the recommended set includes the core lints).
# The core lints are also what is used by pub.dev for scoring packages.

include: package:lints/recommended.yaml

# Uncomment the following section to specify additional rules.

# linter:
#   rules:
#     - camel_case_types

# analyzer:
#   exclude:
#     - path/to/excluded/files/**

# For more information about the core and recommended set of lints, see
# https://dart.dev/go/core-lints

# For additional information about configuring this file, see
# https://dart.dev/guides/language/analysis-options

<!-- END FILE: [v0.2.2] analysis_options.yaml -->

<!-- BEGIN FILE: [v0.2.2] bin/main.dart -->
import 'dart:io';

import 'package:llmifier/llmifier.dart';

/// Application entry point.
///
/// Parses command line arguments, runs the main application logic,
/// and handles global errors.
Future<void> main(List<String> arguments) async {
  int exitCode = 0;

  try {
    print('Starting llmifier...');

    // Instantiate the main application class
    final app = LlmifierApp();

    // Run the application logic and get the exit code
    exitCode = await app.run(arguments);

    print('llmifier finished successfully.');
  } catch (e, stackTrace) {
    // Handle expected errors (like ArgumentError from parsing)
    // or unexpected errors gracefully.
    stderr.writeln('Error: $e');
    // Optionally print stack trace for unexpected errors in debug/verbose mode
    // check for  debug mode
    if (const bool.fromEnvironment('dart.vm.product') == false) {
      stderr.writeln('Stack trace:');
      stderr.writeln(stackTrace);
    } else {
      // In production mode, you might want to log the error to a file or monitoring service
      File('llmifier_log.txt').writeAsStringSync(
        '$e\n$stackTrace',
        mode: FileMode.append,
      );
    }
    exitCode = 1;
    print('llmifier finished with errors.');
  } finally {
    // Ensure the application exits with the determined exit code.
    exit(exitCode);
  }
}

<!-- END FILE: [v0.2.2] bin/main.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/llmifier.dart -->
/// Public entry point for the llmifier library.
///
/// This library primarily exports the main application class [`LlmifierApp`],
/// which is used by the command-line executable and could potentially be used
/// for programmatic integration.
library;

// Export the main application class.
// The `show` keyword explicitly states what is being exported,
// improving clarity. Adjust the path if your file structure differs.
export 'src/app.dart' show LlmifierApp;

<!-- END FILE: [v0.2.2] lib/llmifier.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/app.dart -->
import 'dart:io';

import 'config/argument_parser.dart';
import 'config/config_generator.dart';
import 'config/config_loader.dart';
import 'config/configuration.dart';
import 'config/settings.dart';
import 'extraction/file_extractor.dart';
import 'output/text_output_writer.dart';
import 'processing/project_processor.dart';

/// The main application class responsible for orchestrating the llmifier process.
class LlmifierApp {
  /// Runs the llmifier tool logic based on the provided command line arguments.
  ///
  /// Returns an exit code (0 for success, non-zero for errors).
  Future<int> run(List<String> arguments) async {
    final argumentParser = ArgumentParser();
    Settings settings;
    Configuration configuration;
    // Determine initial verbosity from CLI args for early messages like --init
    bool isInitVerbose =
        arguments.contains('-l') || arguments.contains('--verbose');

    try {
      // 1. Parse CLI arguments
      settings = argumentParser.parse(arguments);

      // Handle --help flag early
      if (settings.showHelp) {
        argumentParser.printUsage();
        return 0; // Success exit code for help
      }

      // --- Handle --init flag early ---
      if (settings.initConfig) {
        print('Configuration file generation requested...');
        final projectDirForInit = settings.projectPath ?? '.';
        final generator = ConfigGenerator();
        final success = await generator.generateDefaultConfig(
          projectDirForInit,
          verbose: isInitVerbose,
        );
        // Exit after attempting generation, return 0 for success, 1 for failure/skip
        return success ? 0 : 1;
      }
      // --- End --init handling ---

      // Print parsed settings if verbose (useful for debugging config loading)
      // Use the potentially updated verbose setting from the parsed settings
      bool isConfigLoadVerbose = settings.verbose ?? false;
      if (isConfigLoadVerbose) {
        print('Parsed CLI Settings: $settings');
      }
    } on FormatException {
      // Error message already printed by parser, usage shown
      return 1; // Indicate failure due to parsing error
    } catch (e, stackTrace) {
      // Catch potential errors during parsing itself
      stderr
          .writeln('An unexpected error occurred during argument parsing: $e');
      // Print stacktrace only if explicitly requested early on
      if (isInitVerbose) {
        stderr.writeln(stackTrace);
      }
      return 1;
    }
    // --- End Argument Parsing Block ---

    // --- Main Execution Block (Loading Config, Extraction, etc.) ---
    // Reset verbosity, will be set by loaded config
    bool isVerbose = false;
    try {
      // 2. Load configuration (using the parsed settings)
      if (settings.verbose ?? false) print('Loading configuration...');
      final configLoader = ConfigLoader();
      configuration = configLoader.load(settings);

      // Use configuration's verbose flag from now on for main process
      isVerbose = configuration.verbose;

      if (isVerbose) {
        print('Effective Configuration loaded:');
        print(configuration.toString());
        print('---'); // Separator
      }

      // 3. Extract files
      if (isVerbose) print('Proceeding with file extraction...');
      final fileExtractor = FileExtractor(configuration);
      final rawFiles = fileExtractor.extractFiles();
      if (isVerbose) print('Extracted ${rawFiles.length} raw files.');

      // 4. Process & Organize Files
      if (isVerbose) {
        print('Proceeding with project processing and file ordering...');
      }
      final projectProcessor = ProjectProcessor(configuration);
      final projectContext = projectProcessor.process(rawFiles);
      if (isVerbose) print('Processing and ordering complete.');

      // 5. Write Output
      if (isVerbose) print('Proceeding with output generation...');
      final outputWriter = TextOutputWriter();
      await outputWriter.write(projectContext, configuration);
      print('Output generated successfully at: ${configuration.outputPath}');

      // If everything completes successfully
      return 0;
    } catch (e, stackTrace) {
      // Catch specific expected exceptions (e.g., FileSystemException during load/extract/write)
      stderr.writeln('An error occurred during execution: $e');
      // Print stack trace if verbose is enabled (using final config setting)
      if (isVerbose) {
        stderr.writeln(stackTrace);
      } else {
        // Optionally add hint to use -v for more details
        stderr.writeln('(Run with -v for more details)');
      }

      // Consider printing usage info on specific argument errors (less likely here now)
      // if (e is ArgumentError) { ArgumentParser().printUsage(); }
      return 1; // Indicate failure
    }
  }
}

<!-- END FILE: [v0.2.2] lib/src/app.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/config/argument_parser.dart -->
import 'dart:io';

import 'package:args/args.dart';

import 'settings.dart'; // Import the Settings class

/// Handles parsing of command-line arguments for the llmifier tool.
class ArgumentParser {
  /// Creates and configures the command-line argument parser.
  ArgParser createParser() {
    return ArgParser()
      // Output Options
      ..addOption(
        'output',
        abbr: 'o',
        help: 'Specify the output file path.\n(e.g., llms-output.txt)',
      )
      ..addOption(
        'project',
        abbr: 'p',
        help: 'Specify the project directory path.\n'
            '(Defaults to the current directory)',
      )

      // Extraction Options
      ..addOption(
        'mode',
        abbr: 'm',
        help: 'Set the extraction mode.',
        allowed: ['full', 'api'], // Enforce allowed values
        // Default value will be handled by Configuration merging
      )
      ..addOption(
        'project-type',
        abbr: 't',
        help: 'Set the project type (influences default file ordering).',
        allowed: ['dart', 'flutter'], // Enforce allowed values
        // Default value will be handled by Configuration merging
      )
      ..addMultiOption(
        'include',
        help: 'Glob pattern for files/directories to include.\n'
            '(Can be specified multiple times)',
      )
      ..addMultiOption(
        'exclude',
        help: 'Glob pattern for files/directories to exclude.\n'
            '(Can be specified multiple times)',
      )

      // Control Flags
      ..addFlag(
        'verbose',
        abbr: 'l',
        negatable: false,
        help: 'Enable verbose logging output.',
      )
      ..addFlag(
        'init',
        abbr: 'i',
        negatable: false,
        help: 'Generate a default llmifierrc.yaml '
            'configuration file in the project directory.',
      )
      ..addFlag(
        'help',
        abbr: 'h',
        negatable: false,
        help: 'Show this help message.',
      );
    // Note: 'includePrivate' is not a direct CLI flag in v1.0 spec,
    // it's handled by the Configuration logic based on mode etc.
  }

  /// Parses the command-line arguments and returns a [Settings] object.
  ///
  /// Throws [FormatException] if parsing fails.
  Settings parse(List<String> arguments) {
    final parser = createParser();
    final ArgResults results;

    try {
      results = parser.parse(arguments);
    } on FormatException catch (e) {
      // Provide context for the format exception
      stderr.writeln('Error parsing arguments: ${e.message}');
      printUsage();
      // Re-throw or handle appropriately - re-throwing allows main to catch it
      rethrow;
    }

    // Handle help flag immediately if present
    if (results['help'] as bool) {
      // Return a Settings object indicating help was requested
      return const Settings(
        includePatterns: [],
        excludePatterns: [],
        verbose: null,
        initConfig: false,
        showHelp: true, // The important flag
      );
    }

    // Extract values from ArgResults
    return Settings(
      outputPath: results['output'] as String?,
      projectPath: results['project'] as String?,
      projectType: results['project-type'] as String?,
      mode: results['mode'] as String?,
      includePatterns: results['include'] as List<String>,
      excludePatterns: results['exclude'] as List<String>,
      verbose: results.wasParsed('verbose') //
          ? (results['verbose'] as bool)
          : null,
      initConfig: results['init'] as bool,
      showHelp: false, // Already handled above
    );
  }

  /// Prints usage information based on the configured argument parser.
  void printUsage() {
    final parser = createParser();
    print('llmifier - Extracts and prepares project files for LLMs.');
    print('');
    print('Usage: llmifier [options]');
    print('');
    print('Options:');
    print(parser.usage);
  }
}

<!-- END FILE: [v0.2.2] lib/src/config/argument_parser.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/config/config_generator.dart -->
import 'dart:io';

import 'package:path/path.dart' as path;

import 'configuration.dart';

/// Handles the generation of a default configuration file (`llmifierrc.yaml`).
class ConfigGenerator {
  static const String _configFileName = 'llmifierrc.yaml';

  /// Generates the default `llmifierrc.yaml` file in the specified [projectPath].
  ///
  /// Checks if the file already exists to prevent accidental overwrites.
  /// Returns `true` if the file was successfully created, `false` otherwise
  /// (e.g., if the file already exists or an error occurred).
  Future<bool> generateDefaultConfig(
    String projectPath, {
    bool verbose = false,
  }) async {
    final configFilePath = path.join(projectPath, _configFileName);
    final configFile = File(configFilePath);

    if (verbose) {
      print('Attempting to generate default config at: $configFilePath');
    }

    if (await configFile.exists()) {
      print('Configuration file already exists at: $configFilePath');
      print('Skipping generation to avoid overwriting.');
      return false;
    }

    try {
      final parentDir = configFile.parent;
      if (!await parentDir.exists()) {
        if (verbose) {
          print('Creating directory: ${parentDir.path}');
        }
        await parentDir.create(recursive: true);
      }
    } on FileSystemException catch (e) {
      stderr.writeln('Error: Could not create directory for config file: $e');
      return false;
    }

    final yamlContent = _buildDefaultYamlContent();

    try {
      await configFile.writeAsString(yamlContent);
      print('Generated default configuration file at: $configFilePath');
      return true;
    } on FileSystemException catch (e) {
      stderr.writeln('Error: Could not write configuration file: $e');
      return false;
    } catch (e) {
      stderr.writeln('An unexpected error occurred during '
          'config file generation: $e');
      return false;
    }
  }

  /// Builds the string content for the default `llmifierrc.yaml` file
  /// based on the values defined in [Configuration.defaults].
  String _buildDefaultYamlContent() {
    final defaults = Configuration.defaults();
    final buffer = StringBuffer();

    // Helper to format YAML lists, quoting items as needed.
    String formatYamlList(
      List<String> items,
      int indent, {
      bool quoteItems = true,
    }) {
      if (items.isEmpty) return '';
      final indentString = ' ' * indent;
      return items
          .map(
            (item) =>
                "$indentString- ${quoteItems ? '"${item.replaceAll('"', '\\"')}"' : item}",
          )
          .join('\n');
    }

    // Header Comment
    buffer.writeln('# llmifier Configuration File (`llmifierrc.yaml`)');
    buffer.writeln('# Generated by `llmifier --init`. Customize as needed.');
    buffer.writeln('# Full documentation: '
        'https://github.com/PhilippHGerber/llmifier');
    buffer.writeln();

    // Basic Settings Section
    buffer.writeln('# --- Basic Settings ---');
    buffer.writeln();
    buffer.writeln('# Output file path. Default: "${defaults.outputPath}"');
    buffer.writeln('# output: "${defaults.outputPath}"');
    buffer.writeln();

    buffer.writeln('# Project type '
        '(influences default include/exclude and fileOrdering).');
    buffer
        .writeln('# Allowed: "dart". Default: "${defaults.projectType.name}"');
    buffer.writeln('projectType: "${defaults.projectType.name}"');
    buffer.writeln();
    buffer.writeln('# Extraction mode: '
        '"full" (all content) or "api" (public API for Dart).');
    buffer.writeln('# Default: "${defaults.mode.name}"');
    buffer.writeln('mode: "${defaults.mode.name}"');
    buffer.writeln();
    buffer.writeln('# Enable verbose logging. Default: ${defaults.verbose}');
    buffer.writeln('# verbose: true');
    buffer.writeln();

    // File Inclusion/Exclusion Section
    buffer.writeln('# --- Global File Inclusion/Exclusion (Glob Patterns) ---');
    buffer.writeln('# These apply BEFORE file ordering. '
        'Files excluded here will not be processed.');
    buffer.writeln();
    buffer.writeln('# Files/Directories to include:');
    buffer.writeln('include:');
    buffer.writeln(formatYamlList(defaults.includePatterns, 2));
    buffer.writeln();
    buffer.writeln('# Files/Directories to exclude (overrides includes):');
    buffer.writeln('exclude:');
    buffer.writeln(formatYamlList(defaults.excludePatterns, 2));
    buffer.writeln();
    buffer.writeln('# Add project-specific global excludes below:');
    buffer.writeln('# - "**/specific_tool_generated_output/"');
    buffer.writeln();

    // File Ordering Section - NEU
    buffer.writeln('# --- File Ordering Strategy ---');
    buffer.writeln('# Defines how included files are grouped '
        'and ordered in the output.');
    buffer.writeln('# Files are assigned to the *first* '
        'matching group in this list.');
    buffer.writeln('fileOrdering:');
    buffer.writeln('  groups:');
    for (final group in defaults.fileOrderingGroups) {
      final groupIndent = '    '; // Indent for group properties
      final listIndent = '      '; // Indent for list items

      buffer.writeln('    - name: "${group.name.replaceAll('"', '\\"')}"');
      buffer.writeln('$groupIndent  patterns:');
      buffer.writeln(formatYamlList(group.patterns, listIndent.length));

      if (group.order.isNotEmpty) {
        buffer.writeln('$groupIndent  order:');
        buffer.writeln(formatYamlList(group.order, listIndent.length));
      }
      // Always write sortBy, even if it's the default, for clarity.
      buffer.writeln('$groupIndent  sortBy: "${group.sortBy.name}"');
      buffer.writeln(); // Blank line after each group for readability
    }
    buffer.writeln('# Example of a custom group:');
    buffer.writeln('#    - name: "Important Configs First"');
    buffer.writeln('#      patterns: '
        '["**/my_critical_config.json", '
        '"**/another_settings.yaml"]');
    buffer.writeln('#      order: ["my_critical_config.json"]');
    buffer.writeln('#      sortBy: "alphabetical"');
    buffer.writeln();
    buffer.writeln('# The last group can be a "catch-all" if desired:');
    buffer.writeln('#    - name: "Other Remaining Files"');
    buffer.writeln('#      patterns: '
        '["**/*"] # Matches anything not caught by earlier groups');
    buffer.writeln('#      sortBy: "alphabetical"');

    return buffer.toString();
  }
}

<!-- END FILE: [v0.2.2] lib/src/config/config_generator.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/config/config_loader.dart -->
import 'dart:io';

import 'package:glob/glob.dart';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

import '../models/enums.dart';
import 'configurable_file_group.dart';
import 'configuration.dart';
import 'settings.dart';
import 'sort_by_option.dart';

/// Loads and merges configuration settings from defaults, a configuration file,
/// and command-line arguments.
class ConfigLoader {
  static const String _configFileName = 'llmifierrc.yaml';

  /// Loads the final [Configuration] by merging settings sources hierarchically.
  ///
  /// Hierarchy (highest priority last):
  /// 1. Default values ([Configuration.defaults])
  /// 2. Configuration file (`llmifierrc.yaml`)
  /// 3. Command-line arguments ([Settings])
  ///
  /// Takes the raw [Settings] parsed from CLI arguments.
  Configuration load(Settings settings) {
    // 1. Start with default configuration
    Configuration currentConfig = Configuration.defaults();
    bool cliVerbose = settings.verbose ?? currentConfig.verbose;

    // Determine the project path to look for the config file
    final String projectPath =
        settings.projectPath ?? currentConfig.projectPath;
    final String configFilePath = path.join(projectPath, _configFileName);
    final configFile = File(configFilePath);

    if (cliVerbose) {
      print('Looking for configuration file at: $configFilePath');
    }

    // 2. Attempt to load and merge from configuration file
    Map<String, dynamic>? yamlData;
    if (configFile.existsSync()) {
      if (cliVerbose) {
        print('Found configuration file. Attempting to load...');
      }
      try {
        yamlData = _loadYamlFile(configFile);
        // Merge base settings first (output, projectPath, mode, etc.)
        currentConfig = _mergeBaseSettingsWithYaml(
          currentConfig,
          yamlData,
          cliVerbose,
        );
        // Now merge fileOrderingGroups specifically
        currentConfig = _mergeFileOrderingGroupsWithYaml(
          currentConfig,
          yamlData,
          cliVerbose,
        );

        if (currentConfig.verbose) {
          // Use verbosity from potentially loaded config
          print('Successfully loaded and merged configuration from file.');
        }
      } catch (e) {
        stderr.writeln(
          'Warning: Could not load or parse configuration file "$_configFileName": $e',
        );
        stderr.writeln('Continuing with default settings and CLI arguments.');
      }
    } else {
      if (cliVerbose) {
        print(
          'Configuration file not found. '
          'Using defaults and CLI arguments.',
        );
      }
    }

    // 3. Merge with CLI settings (highest priority for base settings)
    // FileOrderingGroups are NOT overridden by CLI in this design.
    final finalConfig = _mergeBaseSettingsWithCli(currentConfig, settings);

    // Dynamically add the output file itself to the exclude list
    final String outputFileName = path.basename(finalConfig.outputPath);
    final updatedExcludePatterns =
        List<String>.from(finalConfig.excludePatterns);
    if (!updatedExcludePatterns.contains(outputFileName) &&
        !outputFileName.contains('*')) {
      updatedExcludePatterns.add(outputFileName); // Add specific output file
    } else if (!updatedExcludePatterns.any(
          (p) => Glob(p).matches(outputFileName),
        ) &&
        outputFileName.contains('*')) {
      // Handle if outputPath is a pattern itself, ensure it's excluded
      updatedExcludePatterns.add(outputFileName);
    }

    return Configuration(
      outputPath: finalConfig.outputPath,
      projectPath: finalConfig.projectPath,
      projectType: finalConfig.projectType,
      mode: finalConfig.mode,
      includePatterns: finalConfig.includePatterns,
      excludePatterns: updatedExcludePatterns,
      verbose: finalConfig.verbose,
      fileOrderingGroups: finalConfig.fileOrderingGroups,
    );
  }

  Map<String, dynamic> _loadYamlFile(File file) {
    final String yamlString = file.readAsStringSync();
    final dynamic yamlContent = loadYaml(yamlString);

    if (yamlContent is YamlMap) {
      // Convert YamlMap to standard Dart Map<String, dynamic>
      return _convertYamlMapToDartMap(yamlContent);
    } else if (yamlContent == null) {
      return <String, dynamic>{};
    } else {
      throw FormatException('Configuration file content must be a YAML map.');
    }
  }

  /// Recursively converts a YamlMap to a standard Dart Map.
  Map<String, dynamic> _convertYamlMapToDartMap(YamlMap yamlMap) {
    final Map<String, dynamic> map = {};
    yamlMap.forEach((key, value) {
      if (key is String) {
        map[key] = _convertYamlNodeToDartObject(value);
      }
    });
    return map;
  }

  /// Recursively converts a YamlList to a standard Dart List.
  List<dynamic> _convertYamlListToDartList(YamlList yamlList) {
    return yamlList.map(_convertYamlNodeToDartObject).toList();
  }

  /// Converts any YAML node to its Dart equivalent.
  dynamic _convertYamlNodeToDartObject(dynamic node) {
    if (node is YamlMap) {
      return _convertYamlMapToDartMap(node);
    } else if (node is YamlList) {
      return _convertYamlListToDartList(node);
    }
    return node;
  }

  /// Merges configuration from a YAML map into the current configuration.
  Configuration _mergeBaseSettingsWithYaml(
    Configuration baseConfig,
    Map<String, dynamic> yamlData,
    bool verboseLog,
  ) {
    T? getYamlValue<T>(String key, T? defaultValue) {
      final value = yamlData[key];
      if (value is T) return value;
      if (value != null && verboseLog) {
        print("YAML: Invalid type for '$key'. "
            "Expected $T, got ${value.runtimeType}. Using base.");
      }
      return defaultValue;
    }

    // Helper function to safely get List<String>
    List<String>? getYamlStringList(String key) {
      final value = yamlData[key];
      if (value is List) {
        if (value.every((item) => item is String)) {
          return List<String>.from(value);
        }
        if (verboseLog) {
          print("YAML: List for '$key' has non-string elements. Ignoring.");
        }
      } else if (value != null && verboseLog) {
        print(
            "YAML: Invalid type for '$key'. Expected List, got ${value.runtimeType}. Ignoring.");
      }
      return null;
    }

    ProjectType projectType = baseConfig.projectType;
    final String? yamlProjectType = getYamlValue<String>('projectType', null);
    if (yamlProjectType != null) {
      try {
        projectType = ProjectType.values.byName(yamlProjectType.toLowerCase());
      } catch (_) {
        if (verboseLog) {
          print(
            "YAML: Invalid value '$yamlProjectType' "
            "for 'projectType'. Using base.",
          );
        }
      }
    }

    ExtractionMode mode = baseConfig.mode;
    final String? yamlMode = getYamlValue<String>('mode', null);
    if (yamlMode != null) {
      try {
        mode = ExtractionMode.values.byName(yamlMode.toLowerCase());
      } catch (_) {
        if (verboseLog) {
          print("YAML: Invalid value '$yamlMode' for 'mode'. Using base.");
        }
      }
    }

    return Configuration(
      outputPath: getYamlValue<String>('output', baseConfig.outputPath) ??
          baseConfig.outputPath,
      projectPath: getYamlValue<String>('project', baseConfig.projectPath) ??
          baseConfig.projectPath,
      projectType: projectType,
      mode: mode,
      includePatterns:
          getYamlStringList('include') ?? baseConfig.includePatterns,
      excludePatterns:
          getYamlStringList('exclude') ?? baseConfig.excludePatterns,
      verbose: getYamlValue<bool>('verbose', baseConfig.verbose) ??
          baseConfig.verbose,
      fileOrderingGroups: baseConfig.fileOrderingGroups,
    );
  }

  Configuration _mergeFileOrderingGroupsWithYaml(Configuration baseConfig,
      Map<String, dynamic> yamlData, bool verboseLog) {
    final fileOrderingSection = yamlData['fileOrdering'];
    if (fileOrderingSection is! Map<String, dynamic>) {
      if (fileOrderingSection != null && verboseLog) {
        print(
          "YAML: 'fileOrdering' section is not a map. "
          "Using default/previous groups.",
        );
      }
      return baseConfig; // No valid section, return base
    }

    final groupsData = fileOrderingSection['groups'];
    if (groupsData is! List) {
      if (groupsData != null && verboseLog) {
        print(
          "YAML: 'fileOrdering.groups' is not a list. "
          "Using default/previous groups.",
        );
      }
      return baseConfig; // No valid groups list, return base
    }

    final List<ConfigurableFileGroup> loadedGroups = [];
    for (final groupEntry in groupsData) {
      if (groupEntry is! Map<String, dynamic>) {
        if (verboseLog) {
          print(
            "YAML: Entry in 'fileOrdering.groups' is not a map. "
            "Skipping entry.",
          );
        }
        continue;
      }

      final String? name = groupEntry['name'] as String?;
      final List<dynamic>? patternsDynamic =
          groupEntry['patterns'] as List<dynamic>?;
      final List<dynamic>? orderDynamic = groupEntry['order'] as List<dynamic>?;
      final String? sortByString = groupEntry['sortBy'] as String?;

      if (name == null || name.isEmpty) {
        if (verboseLog) {
          print(
            "YAML: Group missing 'name' or name is empty. "
            "Skipping group.",
          );
        }
        continue;
      }
      if (patternsDynamic == null ||
          patternsDynamic.isEmpty ||
          !patternsDynamic.every((p) => p is String)) {
        if (verboseLog) {
          print(
            "YAML: Group '$name' missing 'patterns', patterns empty, or not all strings. "
            "Skipping group.",
          );
        }
        continue;
      }
      final List<String> patterns = List<String>.from(patternsDynamic);
      final List<String> order =
          (orderDynamic != null && orderDynamic.every((o) => o is String))
              ? List<String>.from(orderDynamic)
              : const []; // Default to empty if invalid or not present

      SortByOption sortBy = SortByOption.alphabetical; // Default
      if (sortByString != null) {
        try {
          sortBy = SortByOption.values.byName(sortByString.toLowerCase());
        } catch (_) {
          if (verboseLog) {
            print(
              "YAML: Group '$name' has invalid 'sortBy' value '$sortByString'. "
              "Using default '${sortBy.name}'.",
            );
          }
        }
      }
      loadedGroups.add(ConfigurableFileGroup(
        name: name,
        patterns: patterns,
        order: order,
        sortBy: sortBy,
      ));
    }

    if (loadedGroups.isEmpty && groupsData.isNotEmpty && verboseLog) {
      print(
        "YAML: 'fileOrdering.groups' was present but no valid groups could be loaded. "
        "Using default/previous groups.",
      );
      return baseConfig;
    }
    if (loadedGroups.isEmpty && groupsData.isEmpty && verboseLog) {
      // This is fine, means user wants to clear default groups or provided an empty list
      print(
        "YAML: 'fileOrdering.groups' is empty. "
        "All files will fall into a default 'Other' group or be unsorted if no catch-all.",
      );
    }

    // If any groups were successfully loaded from YAML, they REPLACE the default groups.
    // If 'fileOrdering.groups' was present but empty or invalid, use baseConfig.fileOrderingGroups (which are defaults).
    // If 'fileOrdering.groups' was valid and empty, loadedGroups will be empty, effectively clearing default groups.
    return Configuration(
        outputPath: baseConfig.outputPath,
        projectPath: baseConfig.projectPath,
        projectType: baseConfig.projectType,
        mode: baseConfig.mode,
        includePatterns: baseConfig.includePatterns,
        excludePatterns: baseConfig.excludePatterns,
        verbose: baseConfig.verbose,
        fileOrderingGroups: loadedGroups.isNotEmpty || (groupsData.isEmpty)
            ? loadedGroups // Use loaded groups if any, or if explicitly emptied
            : baseConfig
                .fileOrderingGroups // Fallback to base (defaults) if section was missing or invalid
        );
  }

  Configuration _mergeBaseSettingsWithCli(
    Configuration baseConfig,
    Settings settings,
  ) {
    ProjectType projectType = baseConfig.projectType;
    if (settings.projectType != null) {
      try {
        projectType = ProjectType.values.byName(
          settings.projectType!.toLowerCase(),
        );
      } catch (_) {
        if (settings.verbose ?? baseConfig.verbose) {
          print("CLI: Invalid value '${settings.projectType}' "
              "for '--project-type'. Ignoring.");
        }
      }
    }

    ExtractionMode mode = baseConfig.mode;
    if (settings.mode != null) {
      try {
        mode = ExtractionMode.values.byName(settings.mode!.toLowerCase());
      } catch (_) {
        if (settings.verbose ?? baseConfig.verbose) {
          print("CLI: Invalid value '${settings.mode}' "
              "for '--mode'. Ignoring.");
        }
      }
    }

    return Configuration(
      outputPath: settings.outputPath ?? baseConfig.outputPath,
      projectPath: settings.projectPath ?? baseConfig.projectPath,
      projectType: projectType,
      mode: mode,
      includePatterns: settings.includePatterns.isNotEmpty
          ? settings.includePatterns
          : baseConfig.includePatterns,
      excludePatterns: settings.excludePatterns.isNotEmpty
          ? settings.excludePatterns
          : baseConfig.excludePatterns,
      verbose: settings.verbose ?? baseConfig.verbose,
      fileOrderingGroups: baseConfig
          .fileOrderingGroups, // CLI does not override fileOrderingGroups
    );
  }
}

<!-- END FILE: [v0.2.2] lib/src/config/config_loader.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/config/configurable_file_group.dart -->
import 'package:glob/glob.dart';
import 'package:meta/meta.dart';

import 'sort_by_option.dart';

/// Represents a user-configurable group of files for ordering purposes.
///
/// Instances of this class are typically created by parsing the
/// `fileOrdering.groups` section of the `llmifierrc.yaml` configuration file.
@immutable
class ConfigurableFileGroup {
  /// The display name of the group (e.g., "Documentation", "API").
  /// Used primarily for logging and debugging.
  final String name;

  /// A list of glob patterns that define which files belong to this group.
  /// A file is considered part of this group if it matches any of these patterns.
  final List<String> patterns;

  /// An optional list of specific file basenames (e.g., "README.md", "pubspec.yaml")
  /// that should appear at the beginning of this group, in the specified order.
  /// Files matched by `order` are processed before other files in this group
  /// that are sorted by `sortBy`.
  final List<String> order;

  /// The strategy to use for sorting files within this group, after
  /// files specified in `order` have been placed.
  final SortByOption sortBy;

  // Cache compiled globs for efficiency
  late final List<Glob> _compiledGlobs = patterns.map((p) => Glob(p)).toList();

  /// Creates a new [ConfigurableFileGroup].
  ///
  /// - [name]: Must not be empty.
  /// - [patterns]: Must not be empty.
  /// - [order]: Defaults to an empty list if not provided.
  /// - [sortBy]: Defaults to [SortByOption.alphabetical] if not provided.
  ConfigurableFileGroup({
    required this.name,
    required this.patterns,
    this.order = const [], // Default to empty list
    this.sortBy = SortByOption.alphabetical, // Default sort option
  }) {
    if (name.isEmpty) {
      throw ArgumentError.value(name, 'name', 'Group name cannot be empty.');
    }
    if (patterns.isEmpty) {
      throw ArgumentError.value(
        patterns,
        'patterns',
        'Group patterns list cannot be empty.',
      );
    }
  }

  /// Checks if the given [relativePath] matches any of the glob patterns
  /// defined for this group.
  ///
  /// Expects [relativePath] to use forward slashes ('/').
  bool matches(String relativePath) {
    if (relativePath.isEmpty) return false;
    return _compiledGlobs.any((glob) => glob.matches(relativePath));
  }

  @override
  String toString() {
    return 'ConfigurableFileGroup(name: "$name", patterns: $patterns, order: $order, sortBy: $sortBy)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! ConfigurableFileGroup) return false;
    // For simplicity in this context, comparing by name might be enough
    // if names are expected to be unique. Or compare all fields for full equality.
    return runtimeType == other.runtimeType &&
        name == other.name &&
        // Using simple list equality for patterns and order for this example
        _listEquals(patterns, other.patterns) &&
        _listEquals(order, other.order) &&
        sortBy == other.sortBy;
  }

  @override
  int get hashCode =>
      name.hashCode ^
      patterns.fold(0, (prev, curr) => prev ^ curr.hashCode) ^
      order.fold(0, (prev, curr) => prev ^ curr.hashCode) ^
      sortBy.hashCode;

  /// Helper for list equality.
  bool _listEquals<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}

<!-- END FILE: [v0.2.2] lib/src/config/configurable_file_group.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/config/configuration.dart -->
import '../models/enums.dart';
import 'configurable_file_group.dart';
import 'sort_by_option.dart';

/// Represents the fully resolved configuration for the llmifier tool.
///
/// This object merges defaults, configuration file settings, and CLI arguments
/// into the final settings used for processing.
class Configuration {
  /// The final path for the output file.
  final String outputPath;

  /// The final path to the project directory.
  final String projectPath;

  /// The determined project type.
  final ProjectType projectType;

  /// The determined extraction mode.
  final ExtractionMode mode;

  /// List of glob patterns for files/directories to include globally.
  final List<String> includePatterns;

  /// List of glob patterns for files/directories to exclude globally.
  final List<String> excludePatterns;

  /// Whether verbose output is enabled.
  final bool verbose;

  /// The user-defined or default configuration for file ordering.
  /// The order of groups in this list determines their output priority.
  final List<ConfigurableFileGroup> fileOrderingGroups;

  /// Creates a new, fully resolved [Configuration] instance.
  const Configuration({
    required this.outputPath,
    required this.projectPath,
    required this.projectType,
    required this.mode,
    required this.includePatterns,
    required this.excludePatterns,
    required this.verbose,
    required this.fileOrderingGroups,
  });

  /// Provides the default configuration values.
  factory Configuration.defaults() {
    // --- Define the effective default patterns based on testing ---
    final defaultIncludes = [
      // Specific file names (Root + Nested)
      "**README.md",
      "**CHANGELOG.md",
      "**LICENSE",
      "**CONTRIBUTING.md",
      "**pubspec.yaml",
      // Files within specific directories (Root + Nested)
      "**lib/**.dart",
      "**bin/**.dart",
      "**test/**.dart",
      "**example/**.dart",
      // Other common file types
      "**analysis_options.yaml",
      "**build.yaml",
    ];

    final defaultExcludes = [
      // Specific Generated File Types (Root + Nested) -> Requires two patterns
      "*.g.dart", // Root
      "**/*.g.dart", // Nested
      "*.freezed.dart", // Root
      "**/*.freezed.dart", // Nested

      // Directories (Root + Nested) - Use **<dirname> (without trailing slash)
      "**build",
      "**.dart_tool",
      "**.git",
      "**.github",
      "**.idea",
      "**.vscode",
      "**node_modules",
      "**ios",
      "**android",
      "**web",
      "**macos",
      "**linux",
      "**windows",
      // All Hidden Files/Dirs
      ".*",
      "**/.*",
      // Output file itself (will be dynamically added by ConfigLoader)
      "llms*.txt",
      "**/llms*.txt",
    ];

    // --- Define Default File Ordering Groups ---
    // This mimics the spirit of the original v0.0.3 fixed ordering.
    final defaultFileOrderingGroups = [
      ConfigurableFileGroup(
        name: "Documentation",
        patterns: [
          "README.md",
          "CHANGELOG.md",
          "LICENSE",
          "CONTRIBUTING.md",
          "docs/**",
        ],
        order: ["README.md", "CHANGELOG.md", "LICENSE", "CONTRIBUTING.md"],
        sortBy: SortByOption.alphabetical,
      ),
      ConfigurableFileGroup(
        name: "Metadata",
        patterns: ["pubspec.yaml", "analysis_options.yaml", "build.yaml"],
        order: ["pubspec.yaml", "analysis_options.yaml", "build.yaml"],
        sortBy: SortByOption.alphabetical,
      ),
      ConfigurableFileGroup(
        name: "Executable",
        patterns: ["bin/**"],
        sortBy: SortByOption.depthFirst,
      ),
      ConfigurableFileGroup(
        name: "Application Code",
        patterns: ["lib/**"],
        sortBy: SortByOption.depthFirst,
      ),
      ConfigurableFileGroup(
        name: "Packages",
        patterns: ["packages/**"],
        order: ["README.md", "CHANGELOG.md", "pubspec.yaml"],
        sortBy: SortByOption.depthFirst,
      ),
      ConfigurableFileGroup(
        name: "Example",
        patterns: ["example/**"],
        order: ["README.md", "CHANGELOG.md", "pubspec.yaml"],
        sortBy: SortByOption.depthFirst,
      ),
      ConfigurableFileGroup(
        name: "Test",
        patterns: ["test/**"],
        sortBy: SortByOption.depthFirst,
      ),
      ConfigurableFileGroup(
        name: "Other Project Files", // For other top-level config or scripts
        patterns: ["*.yaml", "*.json", "*.toml", "*.sh", "*.bat"],
        sortBy: SortByOption.alphabetical,
      ),
      ConfigurableFileGroup(
        name: "Other (Catch-all)",
        patterns: ["**/*"], // Must be last to catch anything not matched above
        sortBy: SortByOption.alphabetical,
      ),
    ];

    return Configuration(
      outputPath: 'llms.txt',
      projectPath: '.',
      projectType: ProjectType.dart,
      mode: ExtractionMode.full,
      includePatterns: defaultIncludes,
      excludePatterns: defaultExcludes,
      verbose: false,
      fileOrderingGroups: defaultFileOrderingGroups,
    );
  }

  @override
  String toString() {
    final groupsString = fileOrderingGroups
        .map(
          (g) => g.toString(),
        )
        .join(',\n    ');
    return 'Configuration(\n'
        '  outputPath: $outputPath,\n'
        '  projectPath: $projectPath,\n'
        '  projectType: $projectType,\n'
        '  mode: $mode,\n'
        '  includePatterns: $includePatterns,\n'
        '  excludePatterns: $excludePatterns,\n'
        '  verbose: $verbose,\n'
        '  fileOrderingGroups: [\n    $groupsString\n  ]\n'
        ')';
  }
}

<!-- END FILE: [v0.2.2] lib/src/config/configuration.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/config/settings.dart -->
/// Represents the raw settings parsed directly from command-line arguments.
///
/// This class holds the values provided by the user via the CLI, before
/// defaults or configuration file values are merged.
class Settings {
  /// Path to the output file specified via CLI. Null if not specified.
  final String? outputPath;

  /// Path to the project directory specified via CLI. Null if not specified.
  final String? projectPath;

  /// Project type specified via CLI (e.g., "dart", "flutter"). Null if not specified.
  final String? projectType;

  /// Extraction mode specified via CLI (e.g., "full", "api"). Null if not specified.
  final String? mode;

  /// List of include patterns specified via CLI. Empty list if none specified.
  final List<String> includePatterns;

  /// List of exclude patterns specified via CLI. Empty list if none specified.
  final List<String> excludePatterns;

  /// Whether verbose output was requested via CLI.
  final bool? verbose;

  /// Whether config file initialization was requested via CLI.
  final bool initConfig;

  /// Whether help was requested via CLI.
  final bool showHelp;

  /// Creates a new instance of [Settings].
  const Settings({
    this.outputPath,
    this.projectPath,
    this.projectType,
    this.mode,
    required this.includePatterns,
    required this.excludePatterns,
    this.verbose,
    required this.initConfig,
    required this.showHelp,
  });

  @override
  String toString() {
    // Useful for debugging
    return 'Settings(outputPath: $outputPath, projectPath: $projectPath, '
        'projectType: $projectType, mode: $mode, '
        'includePatterns: $includePatterns, excludePatterns: $excludePatterns, '
        'verbose: ${verbose ?? 'unset'}, initConfig: $initConfig, showHelp: $showHelp)';
  }
}

<!-- END FILE: [v0.2.2] lib/src/config/settings.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/config/sort_by_option.dart -->
/// Defines the available strategies for sorting files within a [ConfigurableFileGroup].
enum SortByOption {
  /// Sorts files alphabetically by their relative path.
  alphabetical,

  /// Sorts files first by directory depth (ascending), then alphabetically.
  /// Ideal for source code directories like 'lib/' or 'test/'.
  depthFirst,
}

<!-- END FILE: [v0.2.2] lib/src/config/sort_by_option.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/core/file_ordering_strategy.dart -->
import 'package:collection/collection.dart';
import 'package:path/path.dart' as p;

import '../config/configurable_file_group.dart';
import '../config/configuration.dart';
import '../config/sort_by_option.dart';
import '../models/file_entry.dart';

/// Organizes a list of [FileEntry] objects based on user-defined or default
/// [ConfigurableFileGroup] settings from the [Configuration].
class FileOrderingStrategy {
  final List<ConfigurableFileGroup> _fileGroupsConfig;
  final bool _verbose;

  /// Creates a [FileOrderingStrategy].
  ///
  /// Requires the final [Configuration] to access `fileOrderingGroups` and `verbose` settings.
  FileOrderingStrategy(Configuration config)
      : _fileGroupsConfig = config.fileOrderingGroups,
        _verbose = config.verbose;

  /// Organizes the given list of [allFiles] based on the configured strategy.
  ///
  /// Returns a new list containing the same files but in the prioritized
  /// and sorted order.
  List<FileEntry> organizeFiles(List<FileEntry> allFiles) {
    if (allFiles.isEmpty) {
      return [];
    }
    if (_verbose) {
      print(
        'FileOrderingStrategy: '
        'Starting to organize ${allFiles.length} files.',
      );
      print('Using ${_fileGroupsConfig.length} configured file groups.');
    }

    final List<FileEntry> finalSortedFiles = [];
    final Set<FileEntry> globallyProcessedFiles = {};

    // 1. Global group assignment (as before)
    final Map<String, List<FileEntry>> filesAssignedToGroup = {};
    for (final groupConfig in _fileGroupsConfig) {
      filesAssignedToGroup[groupConfig.name] = [];
    }

    for (final fileEntry in allFiles) {
      if (globallyProcessedFiles.contains(fileEntry)) continue;
      for (final groupConfig in _fileGroupsConfig) {
        if (groupConfig.matches(fileEntry.relativePath)) {
          filesAssignedToGroup[groupConfig.name]!.add(fileEntry);
          globallyProcessedFiles.add(fileEntry);
          break; // File assigned to this group, move to next file
        }
      }
    }

    // 2. Process each configured group
    for (final groupConfig in _fileGroupsConfig) {
      final filesInThisGroup = filesAssignedToGroup[groupConfig.name] ?? [];
      if (filesInThisGroup.isEmpty) continue;

      if (_verbose) {
        print(
          '\nProcessing group "${groupConfig.name}" '
          'with ${filesInThisGroup.length} files.',
        );
      }

      // Process files of this group with the new context-aware logic
      final orderedFilesInGroup = _processGroupFilesInContexts(
        filesInThisGroup,
        groupConfig,
      );
      finalSortedFiles.addAll(orderedFilesInGroup);
    }

    if (_verbose) {
      print(
        '\nFileOrderingStrategy: Organization complete. '
        'Final list has ${finalSortedFiles.length} files.',
      );
      // finalSortedFiles.forEach((f) => print('  - ${f.relativePath}'));
    }
    return finalSortedFiles;
  }

  /// Processes files within a single configured group, aiming to apply 'order'
  /// and 'sortBy' contextually based on directory levels.
  List<FileEntry> _processGroupFilesInContexts(
    List<FileEntry> files,
    ConfigurableFileGroup groupConfig,
  ) {
    if (files.isEmpty) return [];

    // Step 1: Group files by their "primary context path"
    // For `lib/**`: context is `lib`
    // For `README.md`: context is `.` (Root)
    Map<String, List<FileEntry>> filesByContextPath = {};

    for (var file in files) {
      final contextPath = _getContextPathForFile(
        file.relativePath,
        groupConfig,
      );
      filesByContextPath.putIfAbsent(contextPath, () => []).add(file);
    }

    if (_verbose && filesByContextPath.length > 1) {
      print(
        '  Group "${groupConfig.name}": Identified ${filesByContextPath.keys.length} '
        'contexts: ${filesByContextPath.keys.join(", ")}',
      );
    }

    // Step 2: Sort the contexts themselves (e.g., alphabetically)
    List<String> sortedContextPaths = filesByContextPath.keys.toList();
    // Here, we might want a more sophisticated way to sort contexts if needed,
    // e.g., if "packages/core" should come before "packages/feature_a".
    // For now, natural string comparison is used.
    sortedContextPaths.sort(compareNatural);

    // Step 3: Process each context
    List<FileEntry> result = [];
    for (var contextPath in sortedContextPaths) {
      List<FileEntry> filesInThisContext = filesByContextPath[contextPath]!;
      if (_verbose && filesByContextPath.length > 1) {
        // Log only if there are multiple contexts for clarity
        print(
          '    Processing context "$contextPath" '
          'with ${filesInThisContext.length} files...',
        );
      }

      List<FileEntry> orderedByDirective = [];
      List<FileEntry> remainingInContext = List.from(filesInThisContext);

      // Apply `groupConfig.order` directive *within this context*
      if (groupConfig.order.isNotEmpty) {
        final Set<FileEntry> placedByOrder = {};

        // Iterate through the 'order' list defined in the group configuration
        for (final orderedBaseName in groupConfig.order) {
          // Find files in the current context that match this basename
          List<FileEntry> matchingFilesInContextForOrder = [];
          for (final entry in remainingInContext) {
            bool isInContext;
            if (contextPath == ".") {
              // For root context, a file is in context if its dirname is '.'
              // This means it's directly in the root, not in a subdirectory.
              isInContext = p.url.dirname(entry.relativePath) == ".";
            } else {
              // For non-root contexts, check if the path starts with the contextPath
              isInContext = entry.relativePath.startsWith(contextPath);
            }

            if (p.basename(entry.relativePath) == orderedBaseName &&
                isInContext && // Verwende die neue Variable isInContext
                !placedByOrder.contains(entry)) {
              matchingFilesInContextForOrder.add(entry);
            }
          }

          // If multiple files match the basename (e.g. multiple README.md in different subdirs of the context),
          // sort them by path to ensure deterministic order before adding.
          matchingFilesInContextForOrder.sort(
            (a, b) => compareNatural(a.relativePath, b.relativePath),
          );

          for (final entryToAdd in matchingFilesInContextForOrder) {
            if (!placedByOrder.contains(entryToAdd)) {
              // Double check to avoid duplicates if logic changes
              orderedByDirective.add(entryToAdd);
              placedByOrder.add(entryToAdd);
            }
          }
        }
        remainingInContext.removeWhere(
          (entry) => placedByOrder.contains(entry),
        );

        if (_verbose && orderedByDirective.isNotEmpty) {
          print(
            '      Context "$contextPath": '
            'Applied fixed order for ${orderedByDirective.length} files.',
          );
        }
      }

      // Sort the remaining files in the context using `groupConfig.sortBy`
      _sortListOfFiles(remainingInContext, groupConfig.sortBy);
      if (_verbose && remainingInContext.isNotEmpty) {
        print(
            '      Context "$contextPath": Sorted remaining ${remainingInContext.length} files by ${groupConfig.sortBy.name}.');
      }

      result.addAll(orderedByDirective);
      result.addAll(remainingInContext);
    }
    return result;
  }

  /// Determines the "context path" for a file relative to a group's patterns.
  /// This is a critical heuristic and may need refinement.
  /// The goal is to identify the main subdirectory or scope a file belongs to
  /// within a broader group pattern (e.g., "packages/my_package" from "packages/**").
  String _getContextPathForFile(
    String relativePath,
    ConfigurableFileGroup groupCfg,
  ) {
    List<String> pathSegments = p.url.split(relativePath);

    // Try to find the most specific directory part based on group patterns.
    // This is a simplification. A more robust solution might involve
    // finding the longest non-glob prefix of a matching pattern.
    for (String patternStr in groupCfg.patterns) {
      if (patternStr.endsWith('/**')) {
        String basePatternDir = patternStr.substring(
          0,
          patternStr.length - 3,
        );
        if (relativePath.startsWith(basePatternDir)) {
          if (basePatternDir == "." || basePatternDir.isEmpty) {
            // e.g. pattern "/**"
            return pathSegments.isNotEmpty ? pathSegments.first : ".";
          }
          List<String> basePatternParts = p.url.split(basePatternDir);

          if (pathSegments.length > basePatternParts.length) {
            return p.url.joinAll(
              pathSegments.sublist(0, basePatternParts.length + 1),
            );
          } else if (pathSegments.length == basePatternParts.length &&
              pathSegments.join('/') == basePatternParts.join('/')) {
            // File is directly in the basePatternDir, e.g. pattern "lib/**" and file "lib/app.dart" (context "lib")
            return basePatternDir;
          }
        }
      } else if (!patternStr.contains('*')) {
        // Exact file pattern
        if (patternStr == relativePath) {
          String dirname = p.url.dirname(relativePath);
          return dirname == "." ? "." : dirname; // Return "." for root files
        }
      }
      // Other pattern types (e.g., "lib/*.dart") would need more specific logic
      // to determine their "context". For now, they'll use the fallback.
    }

    // Fallback heuristic:
    // For paths like "a/b/c.dart", if the group is broad (e.g. "**/*"),
    // we might consider "a" or "a/b" as context.
    // If the first segment matches a common top-level dir from patterns (e.g. "packages", "examples", "lib")
    // and there's a subdirectory, that subdirectory becomes the context.
    if (pathSegments.length > 1) {
      String firstSegment = pathSegments.first;
      bool isKnownTopLevelPattern = groupCfg.patterns.any(
        (pat) => pat.startsWith("$firstSegment/**"),
      );
      if (isKnownTopLevelPattern) {
        return p.url.join(
          pathSegments[0],
          pathSegments[1],
        );
      }
      // If not a known top-level pattern, the context might be just the first directory.
      // Or, for files directly in root matched by a root-level pattern like "*.yaml", context is "."
      if (p.url.dirname(relativePath) == ".") return ".";
      return firstSegment;
    }
    return "."; // Default to root context
  }

  /// Sorts a given list of [FileEntry]s based on the [SortByOption].
  void _sortListOfFiles(List<FileEntry> files, SortByOption sortBy) {
    if (files.isEmpty) return;

    switch (sortBy) {
      case SortByOption.alphabetical:
        files.sort((a, b) => compareNatural(a.relativePath, b.relativePath));
        break;
      case SortByOption.depthFirst:
        files.sort((a, b) {
          // Using global depth, which usually works well.
          // For true relative depth-sorting within a context, metadata.depth
          // would need to be recalculated or adjusted based on the contextPath.
          final depthCompare = a.metadata.depth.compareTo(b.metadata.depth);
          if (depthCompare != 0) {
            return depthCompare;
          }
          return compareNatural(a.relativePath, b.relativePath);
        });
        break;
    }
  }
}

<!-- END FILE: [v0.2.2] lib/src/core/file_ordering_strategy.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/extraction/file_extractor.dart -->
import 'dart:io';

import 'package:glob/glob.dart';
import 'package:path/path.dart' as path;

// Local imports
import '../config/configuration.dart';
import '../models/file_entry.dart';
import '../models/file_metadata.dart';

/// Extracts relevant files from the project directory based on the configuration.
class FileExtractor {
  final Configuration _config;
  final List<Glob> _includeGlobs;
  final List<Glob> _excludeGlobs;

  /// Creates a [FileExtractor] instance.
  ///
  /// Requires the final [Configuration] object.
  /// Pre-compiles the glob patterns for efficiency.
  FileExtractor(this._config)
      : _includeGlobs = _config.includePatterns.map((p) => Glob(p)).toList(),
        _excludeGlobs = _config.excludePatterns.map((p) => Glob(p)).toList() {
    if (_config.verbose) {
      print('FileExtractor initialized.');
      print('Include patterns: ${_config.includePatterns}');
      print('Exclude patterns: ${_config.excludePatterns}');
    }
  }

  /// Extracts all files matching the include/exclude criteria.
  ///
  /// Returns a list of [FileEntry] objects, each including calculated [FileMetadata].
  /// The list is not sorted according to the final ordering strategy at this stage.
  List<FileEntry> extractFiles() {
    final List<FileEntry> extractedFiles = [];
    final projectDir = Directory(_config.projectPath);

    if (!projectDir.existsSync()) {
      stderr.writeln(
          'Error: Project directory not found: ${_config.projectPath}');
      return [];
    }

    if (_config.verbose) {
      print('Starting file extraction from: ${projectDir.absolute.path}');
    }

    // Start recursive processing
    _processDirectory(projectDir, extractedFiles);

    if (_config.verbose) {
      print('File extraction completed. Found ${extractedFiles.length} files.');
    }

    // Sorting happens later in ProjectProcessor using FileOrderingStrategy
    return extractedFiles;
  }

  /// Recursively processes a directory and its contents.
  void _processDirectory(Directory currentDir, List<FileEntry> results) {
    final String currentDirPathAbsolute =
        path.normalize(currentDir.absolute.path);
    final String projectRootPathAbsolute =
        path.normalize(Directory(_config.projectPath).absolute.path);

    if (_config.verbose) {
      final String relativePathForLog =
          path.relative(currentDirPathAbsolute, from: projectRootPathAbsolute);
      print(
          'Processing directory: ${relativePathForLog.isEmpty ? "." : relativePathForLog}');
    }

    try {
      final List<FileSystemEntity> entities = currentDir.listSync(
        followLinks: false,
      );

      // Sort entities for deterministic order (optional but good practice)
      // Directories first - then alphabetical
      entities.sort((a, b) {
        final aIsDir = a is Directory;
        final bIsDir = b is Directory;
        if (aIsDir && !bIsDir) return -1;
        if (!aIsDir && bIsDir) return 1;
        return path.basename(a.path).compareTo(path.basename(b.path));
      });

      for (final entity in entities) {
        final String entityPathAbsolute = path.normalize(entity.absolute.path);
        final String baseName = path.basename(entityPathAbsolute);

        // 1. Skip hidden files/directories (starting with '.')
        // Added check to prevent infinite loops on links like .git/logs/refs -> ../../logs/refs
        if (baseName.startsWith('.') || entity is Link) {
          if (_config.verbose) {
            if (baseName.startsWith('.')) {
              print('  Skipping hidden entry: $baseName');
            }
            if (entity is Link) print('  Skipping link: $baseName');
          }
          continue;
        }

        // Calculate relative path using forward slashes for matching
        final String relativePath = path
            .relative(entityPathAbsolute, from: projectRootPathAbsolute)
            .replaceAll('\\', '/'); // Ensure forward slashes

        // 2. Check exclusion patterns
        if (_shouldExclude(relativePath, entity is Directory)) {
          if (_config.verbose) {
            print(
                '  Skipping excluded ${entity is Directory ? "directory" : "file"}: $relativePath');
          }
          continue;
        }

        // 3. Process based on type (Directory or File)
        if (entity is Directory) {
          // Recurse into subdirectories
          _processDirectory(entity, results);
        } else if (entity is File) {
          // 4. Check inclusion patterns for files
          if (_shouldInclude(relativePath)) {
            // File matches, add it with metadata
            _addFile(entity, relativePath, results);
          } else {
            if (_config.verbose) {
              print(
                  '  Skipping file (does not match include patterns): $relativePath');
            }
          }
        }
      }
    } on FileSystemException catch (e) {
      stderr
          .writeln("Warning: Could not list directory ${currentDir.path}: $e");
    }
  }

  /// Adds a file to the results list after reading its content and calculating metadata.
  /// Expects relativePath to potentially start with './'.
  void _addFile(File file, String relativePath, List<FileEntry> results) {
    try {
      final String content = file.readAsStringSync();
      // Metadata calculation should handle './' correctly
      final FileMetadata metadata = FileMetadata.fromRelativePath(relativePath);

      results.add(FileEntry(
        relativePath: relativePath,
        content: content,
        metadata: metadata,
      ));

      if (_config.verbose) {
        print('  Added file: $relativePath (Metadata: $metadata)');
      }
    } on FileSystemException catch (e) {
      stderr.writeln("Warning: Could not read file ${file.path}: $e");
    } catch (e) {
      stderr.writeln("Warning: Error processing file ${file.path}: $e");
    }
  }

  /// Checks if a given relative path should be excluded based on exclude globs.
  bool _shouldExclude(String relativePath, bool isDirectory) {
    // Check if any exclude glob matches the relative path.
    // Globs can match files or directories.
    return _excludeGlobs.any((glob) => glob.matches(relativePath));
  }

  /// Checks if a given relative path should be included based on include globs.
  /// Assumes _shouldExclude was already checked and returned false.
  bool _shouldInclude(String relativePath) {
    // If no include patterns are defined, include everything (that wasn't excluded).
    if (_includeGlobs.isEmpty) {
      return true;
    }
    // Otherwise, it must match at least one include pattern.
    // return _includeGlobs.any((glob) => glob.matches(relativePath));
    // Set breakpoint inside this lambda, on the 'glob.matches' call:
    return _includeGlobs.any((glob) {
      bool matches = glob.matches(relativePath); // <--- BREAKPOINT HERE
      // You can also inspect 'glob.pattern' here
      return matches;
    });
  }
}

<!-- END FILE: [v0.2.2] lib/src/extraction/file_extractor.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/models/enums.dart -->
/// Defines the recognized types of projects llmifier can handle.
///
/// This influences default file ordering and potentially processing logic.
enum ProjectType {
  /// A standard Dart/Flutter project (e.g., library, CLI tool, app).
  dart,
}

/// Defines the different modes for extracting content.
enum ExtractionMode {
  /// Extracts the full content of the files. Suitable for reviews or development.
  full,

  /// Extracts only the public API surface with documentation comments. Suitable for package usage context.
  api,
}

<!-- END FILE: [v0.2.2] lib/src/models/enums.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/models/file_entry.dart -->
import 'file_metadata.dart';

/// Represents a single file extracted from the project.
class FileEntry {
  /// The path of the file relative to the project root.
  /// Uses forward slashes ('/') as separators.
  final String relativePath;

  /// The content of the file as a string.
  final String content;

  /// Metadata associated with the file (e.g., depth, extension).
  final FileMetadata metadata; // Added field

  /// Creates a new [FileEntry].
  const FileEntry({
    required this.relativePath,
    required this.content,
    required this.metadata,
  });

  @override
  String toString() {
    // Simple representation for debugging
    return 'FileEntry(relativePath: "$relativePath", content: ${content.length} chars, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileEntry &&
          runtimeType == other.runtimeType &&
          relativePath == other.relativePath &&
          metadata == other.metadata;

  @override
  int get hashCode => relativePath.hashCode ^ metadata.hashCode;
}

<!-- END FILE: [v0.2.2] lib/src/models/file_entry.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/models/file_group.dart -->
import 'package:glob/glob.dart';
import 'package:meta/meta.dart';

/// Represents a semantic group of files defined by a name and glob patterns.
///
/// Used by [FileOrderingStrategy] to categorize files before sorting.
@immutable
class FileGroup {
  /// The unique identifier name for the group (e.g., "Metadata", "API").
  final String name;

  /// The list of glob patterns associated with this group.
  final List<String> patterns;

  // Cache compiled globs for efficiency
  late final List<Glob> _compiledGlobs = patterns.map((p) => Glob(p)).toList();

  /// Creates a definition for a file group.
  FileGroup({required this.name, required this.patterns}) {
    // Basic validation: Ensure name is not empty
    if (name.isEmpty) {
      throw ArgumentError.value(name, 'name', 'Group name cannot be empty.');
    }
  }

  /// Checks if the given [relativePath] matches any of the glob patterns
  /// defined for this group.
  ///
  /// Expects [relativePath] to use forward slashes ('/').
  bool matches(String relativePath) {
    // Handle potential edge case of empty path? For now, assume valid paths.
    if (relativePath.isEmpty) return false;
    return _compiledGlobs.any((glob) => glob.matches(relativePath));
  }

  @override
  String toString() {
    return 'FileGroup(name: "$name", patterns: $patterns)';
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileGroup && //
          runtimeType == other.runtimeType &&
          name == other.name;

  @override
  int get hashCode => name.hashCode;
}

<!-- END FILE: [v0.2.2] lib/src/models/file_group.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/models/file_metadata.dart -->
import 'package:path/path.dart' as path;

/// Represents metadata associated with a file, primarily used for sorting.
///
/// This information is collected by the [FileExtractor] and used by the
/// [FileOrderingStrategy] to determine the correct order of files in the output.
class FileMetadata {
  /// The directory depth of the file relative to the project root.
  /// A file directly in the root has a depth of 0.
  /// `lib/src/file.dart` has a depth of 2.
  final int depth;

  /// The file extension, including the leading dot (e.g., ".dart", ".md").
  /// Returns an empty string if the file has no extension.
  final String extension;

  /// Creates metadata for a file.
  const FileMetadata({
    required this.depth,
    required this.extension,
  });

  /// Creates [FileMetadata] by calculating values from a relative path.
  ///
  /// Expects the [relativePath] to use forward slashes ('/') as separators.
  factory FileMetadata.fromRelativePath(String relativePath) {
    // Calculate depth
    final parts = path.split(relativePath.replaceAll('\\', '/'));
    // If the path only contains the filename (no slashes), parts length is 1, depth is 0.
    // If path is 'lib/file.dart', parts is ['lib', 'file.dart'], length 2, depth 1.
    // The depth is the number of directory components.
    final depth = parts.length > 1 ? parts.length - 1 : 0;

    // Calculate extension
    final extension = path.extension(relativePath);

    return FileMetadata(depth: depth, extension: extension);
  }

  @override
  String toString() {
    return 'FileMetadata(depth: $depth, extension: "$extension")';
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileMetadata && //
          runtimeType == other.runtimeType &&
          depth == other.depth &&
          extension == other.extension;

  @override
  int get hashCode => depth.hashCode ^ extension.hashCode;
}

<!-- END FILE: [v0.2.2] lib/src/models/file_metadata.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/models/project_context.dart -->
// Local imports
import 'enums.dart'; // For ProjectType
import 'file_entry.dart'; // For the list of files

/// Represents the overall context of the processed project.
///
/// This includes metadata about the project (like name and version) and
/// the list of file entries with their processed content.
class ProjectContext {
  /// The determined type of the project.
  final ProjectType type;

  /// The name of the package, extracted from pubspec.yaml (if found).
  final String? packageName;

  /// The version of the package, extracted from pubspec.yaml (if found).
  final String? packageVersion;

  /// The list of file entries after content processing.
  final List<FileEntry> files;

  /// The time when the extraction and processing occurred.
  final DateTime extractionTime;

  /// Creates a new [ProjectContext].
  const ProjectContext({
    required this.type,
    this.packageName,
    this.packageVersion,
    required this.files,
    required this.extractionTime,
  });

  @override
  String toString() {
    return 'ProjectContext(type: $type, packageName: $packageName, '
        'packageVersion: $packageVersion, fileCount: ${files.length}, '
        'extractionTime: $extractionTime)';
  }
}

<!-- END FILE: [v0.2.2] lib/src/models/project_context.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/output/output_writer.dart -->
import '../config/configuration.dart';
import '../models/project_context.dart';

/// Abstract interface for writing the extracted project context to an output destination.
///
/// This allows for different output formats or destinations in the future.
abstract class OutputWriter {
  /// Writes the provided [projectContext] based on the given [config].
  ///
  /// The [projectContext] contains processed files and project metadata.
  /// Implementations should handle potential I/O errors.
  Future<void> write(ProjectContext projectContext, Configuration config);
}

<!-- END FILE: [v0.2.2] lib/src/output/output_writer.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/output/text_output_writer.dart -->
import 'dart:io';

// Local imports
import 'package:intl/intl.dart';

import '../config/configuration.dart';
import '../models/file_entry.dart';
import '../models/project_context.dart';
import '../utils/app_info.dart';
import 'output_writer.dart';

/// An implementation of [OutputWriter] that writes the project context
/// to a single text file.
///
/// Uses BEGIN/END markers, including the project version if available,
/// to delineate file content. Includes project metadata in the header.
class TextOutputWriter implements OutputWriter {
  @override
  Future<void> write(ProjectContext projectContext, Configuration config) async {
    final String outputPath = config.outputPath;
    final List<FileEntry> files = projectContext.files;

    if (config.verbose) {
      print('Starting to write ${files.length} processed files to: $outputPath');
      print('Project Context: $projectContext');
    }

    final buffer = StringBuffer();

    // 1. Write Header
    _writeHeader(buffer, projectContext, config);

    // 2. Write File Entries
    if (files.isEmpty) {
      if (config.verbose) {
        print('No files were processed to write.');
      }
      buffer.writeln('<!-- No files matched the specified criteria or processing resulted in empty list. -->');
      buffer.writeln();
    } else {
      for (final file in files) {
        _writeFileEntry(buffer, file, projectContext, config);
      }
    }

    // 3. Write Footer
    _writeFooter(buffer);

    // 4. Write buffer to the actual file
    try {
      final outputFile = File(outputPath);
      // Ensure the directory exists before writing
      if (!await outputFile.parent.exists()) {
        await outputFile.parent.create(recursive: true);
        if (config.verbose) {
          print('Created directory: ${outputFile.parent.path}');
        }
      }
      await outputFile.writeAsString(buffer.toString());
      if (config.verbose) {
        print('Successfully wrote output to: $outputPath');
      }
    } on FileSystemException catch (e) {
      stderr.writeln('Error writing output file "$outputPath": $e');
      // Re-throwing allows the main application loop to catch and handle it
      rethrow;
    }
  }

  /// Writes the standard header to the buffer using project context and config.
  ///
  /// Includes project name, version (if available), generation time, and settings.
  void _writeHeader(StringBuffer buffer, ProjectContext context, Configuration config) {
    // Use package name and version if available from context
    String title = 'Project Documentation';
    if (context.packageName != null && context.packageName!.isNotEmpty) {
      title += ': ${context.packageName}';
      // Add version only if it's present and not empty
      if (context.packageVersion != null && context.packageVersion!.isNotEmpty) {
        title += ' v${context.packageVersion}';
      }
    }
    String formattedTime = DateFormat('yyyy-MM-ddTHH:mm:ss').format(context.extractionTime);
    buffer.writeln('# $title');
    buffer.writeln();
    buffer.writeln('Generated by llmifier on: $formattedTime');
    buffer.writeln('Extraction Mode: ${config.mode.name}');
    buffer.writeln('Project Type: ${context.type.name}');
    buffer.writeln();
    buffer.writeln('---');
    buffer.writeln();
  }

  /// Writes a single file entry, including BEGIN/END markers with version info,
  /// to the buffer.
  ///
  /// - [buffer]: The [StringBuffer] to write to.
  /// - [file]: The [FileEntry] containing the relative path and content.
  /// - [context]: The [ProjectContext] providing the package version.
  /// - [config]: The [Configuration] for accessing settings like verbose mode.
  void _writeFileEntry(StringBuffer buffer, FileEntry file, ProjectContext context, Configuration config) {
    if (config.verbose) {
      print('  Writing processed file: ${file.relativePath}');
    }

    // Prepare the version marker string, e.g., "[v1.2.3] " or empty string
    String versionMarker = "";
    if (context.packageVersion != null && context.packageVersion!.isNotEmpty) {
      // Format as specified: [vX.Y.Z] followed by a space
      versionMarker = "[v${context.packageVersion}] ";
    }

    // Write the BEGIN marker including the version marker
    buffer.writeln('<!-- BEGIN FILE: $versionMarker${file.relativePath} -->');
    // Write the actual file content
    buffer.writeln(file.content);
    // Write the END marker including the version marker
    buffer.writeln('<!-- END FILE: $versionMarker${file.relativePath} -->');
    // Add a blank line for better separation between file entries
    buffer.writeln();
  }

  /// Writes the standard footer to the buffer using [AppInfo].
  void _writeFooter(StringBuffer buffer) {
    buffer.writeln('---');
    // Include app version and build date
    buffer.writeln('Generated with llmifier v${AppInfo.version}');
    // Include author and optionally repository/package URLs
    buffer.writeln('Created by ${AppInfo.author}');
    // Uncomment the following line to include URLs in the footer:
    buffer.writeln('Repository: ${AppInfo.repositoryUrl}');
    buffer.writeln('Package: ${AppInfo.packageUrl}');
  }
}

<!-- END FILE: [v0.2.2] lib/src/output/text_output_writer.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/processing/api_extractor_visitor.dart -->
// lib/src/processing/api_extractor_visitor.dart (Corrected v6 - Restore Comment Tokens)

import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/token.dart';
import 'package:analyzer/dart/ast/visitor.dart';

class ApiExtractorVisitor extends SimpleAstVisitor<void> {
  final StringBuffer _buffer = StringBuffer();
  int _indentationLevel = 0;
  bool _isFirstMember = true; // Tracks if we need a newline before writing

  final String _sourceContent;

  ApiExtractorVisitor(this._sourceContent);

  StringBuffer get apiOutput => _buffer;

  // --- Helper Methods ---
  bool _isPublic(String? name) {
    if (name == null) return true;
    return !name.startsWith('_');
  }

  void _writeln(String text) {
    // Write the line with current indentation
    _buffer.writeln("${_indent()}$text");
    // Mark that we wrote something, so the next element might need a newline
    _isFirstMember = false;
  }

  void _newLineMaybe() {
    // Add separation if needed before the next element
    if (!_isFirstMember && //
        _buffer.isNotEmpty &&
        !_buffer.toString().endsWith('\n\n')) {
      _buffer.writeln();
    }
    _isFirstMember = true; // Reset before potential write
  }

  String _indent() {
    return '  ' * _indentationLevel;
  }

  // Write documentation if it exists, managing spacing.
  void _writeDocumentation(AnnotatedNode node) {
    Comment? comment = node.documentationComment;
    if (comment != null) {
      Token? token = comment.tokens.first;
      while (token != null) {
        // Write the token's lexeme directly, trim only trailing whitespace
        _writeln(token.lexeme.trimRight());
        if (token == comment.tokens.last) break;
        token = token.next;
      }
      // _isFirstMember is set to false by the last _writeln call.
    }
  }

  String _getSource(int startOffset, int endOffset) {
    if (startOffset < 0 || //
        endOffset > _sourceContent.length ||
        startOffset > endOffset) {
      return '/* Error: Invalid source range ($startOffset..$endOffset) */';
    }
    try {
      // Trim only at the end, preserve leading indentation fetched by offsets
      return _sourceContent.substring(startOffset, endOffset).trimRight();
    } catch (e) {
      return '/* Error retrieving source: $e */';
    }
  }

  bool _isMemberContainer(AstNode? node) {
    return node is ClassDeclaration ||
        node is MixinDeclaration ||
        node is ExtensionDeclaration ||
        node is EnumDeclaration ||
        node is ExtensionTypeDeclaration;
  }

  // --- Visitor Methods (Using node.firstTokenAfterCommentAndMetadata) ---
  // (These methods remain the same as v5, ensuring they call the
  //  now-corrected _writeDocumentation and use firstTokenAfterCommentAndMetadata)

  @override
  void visitCompilationUnit(CompilationUnit node) {
    _isFirstMember = true;
    for (var declaration in node.declarations) {
      declaration.accept(this);
    }
  }

  @override
  void visitClassDeclaration(ClassDeclaration node) {
    if (_isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset = node.leftBracket.end;
      final String signature = _getSource(startOffset, endOffset);
      _writeln(signature);

      _indentationLevel++;
      _isFirstMember = true;
      for (var member in node.members) {
        member.accept(this);
      }
      _indentationLevel--;
      _isFirstMember = false;
      _writeln("}");
    }
  }

  @override
  void visitMixinDeclaration(MixinDeclaration node) {
    if (_isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset = node.leftBracket.end;
      final String signature = _getSource(startOffset, endOffset);
      _writeln(signature);

      _indentationLevel++;
      _isFirstMember = true;
      for (var member in node.members) {
        member.accept(this);
      }
      _indentationLevel--;
      _isFirstMember = false;
      _writeln("}");
    }
  }

  @override
  void visitExtensionDeclaration(ExtensionDeclaration node) {
    final bool isPublic = _isPublic(node.name?.lexeme);
    if (isPublic) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset = node.leftBracket.end;
      final String signature = _getSource(startOffset, endOffset);
      _writeln(signature);

      _indentationLevel++;
      _isFirstMember = true;
      for (var member in node.members) {
        member.accept(this);
      }
      _indentationLevel--;
      _isFirstMember = false;
      _writeln("}");
    }
  }

  @override
  void visitExtensionTypeDeclaration(ExtensionTypeDeclaration node) {
    if (_isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset = node.leftBracket.end;
      final String signature = _getSource(startOffset, endOffset);
      _writeln(signature);

      _indentationLevel++;
      _isFirstMember = true;
      for (var member in node.members) {
        member.accept(this);
      }
      _indentationLevel--;
      _isFirstMember = false;
      _writeln("}");
    }
  }

  @override
  void visitEnumDeclaration(EnumDeclaration node) {
    if (_isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset = node.leftBracket.end;
      final String signature = _getSource(startOffset, endOffset);
      _writeln(signature);

      _indentationLevel++;
      _isFirstMember = true;
      for (var constant in node.constants) {
        constant.accept(this);
      }
      for (var member in node.members) {
        member.accept(this);
      }
      _indentationLevel--;
      _isFirstMember = false;
      _writeln("}");
    }
  }

  @override
  void visitEnumConstantDeclaration(EnumConstantDeclaration node) {
    _writeDocumentation(node);
    for (final annotation in node.metadata) {
      final String annotationSource = _getSource(
        annotation.offset,
        annotation.end,
      );
      _writeln(annotationSource);
    }
    final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
    final int endOffset = node.end;
    final String constSignature = _getSource(startOffset, endOffset);
    final String lineToWrite = constSignature.trimRight().endsWith(',') //
        ? constSignature
        : "$constSignature,";
    _writeln(lineToWrite); // Write the constant line
  }

  @override
  void visitFunctionDeclaration(FunctionDeclaration node) {
    if (node.parent is CompilationUnit && _isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;

      final int endOffset;
      // Check if it's a getter (no parameters) or a regular function/setter
      if (node.isGetter || node.functionExpression.parameters == null) {
        // For GETTERS: Signature ends before the body (e.g., before '=>' or '{').
        endOffset = node.functionExpression.body.offset;
      } else {
        // For regular functions or SETTERS: Signature ends after the parameter list.
        endOffset = node.functionExpression.parameters!.rightParenthesis.end;
      }

      final String signature = _getSource(startOffset, endOffset).trimRight();

      _writeln("$signature;");
    }
  }

  @override
  void visitMethodDeclaration(MethodDeclaration node) {
    if (_isMemberContainer(node.parent) && _isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset;

      if (node.isGetter) {
        // Getter: Type get name; Signature ends before body.
        endOffset = node.body.offset;
      } else if (node.isSetter) {
        // Setter: set name(Type val); Signature ends after parameters.
        endOffset = node.parameters!.rightParenthesis.end;
      } else {
        // Regular method, abstract method, or external method
        if (node.parameters != null) {
          // Method with parameters (even if empty like "method()")
          endOffset = node.parameters!.rightParenthesis.end;
        } else {
          // Method without a parameter list node in AST.
          // This can be an abstract method like "Type m();" or an external method like "external Type m();"
          // or a getter (which is handled above).
          // For abstract/external methods, node.body.offset often points to the semicolon.
          // If the semicolon is part of the body token, we might get it. If not, we add it.
          endOffset = node.body.offset;
        }
      }

      String signature = _getSource(startOffset, endOffset).trimRight();

      // For API view, all method declarations (regular, abstract, external, getters, setters)
      // should end with a semicolon.
      // Getters and setters are handled by their specific offset logic ending before the body,
      // so they will naturally need a semicolon.
      // Regular methods, abstract methods, and external methods also need one.
      if (!signature.endsWith(';')) {
        signature = '$signature;';
      }

      _writeln(signature);
    }
  }

  @override
  void visitConstructorDeclaration(ConstructorDeclaration node) {
    // Check if the parent is a type that can contain constructors
    final parentDeclaration = node.parent; // Get the parent node
    if (parentDeclaration is ClassDeclaration ||
        parentDeclaration is MixinDeclaration ||
        parentDeclaration is EnumDeclaration ||
        parentDeclaration is ExtensionTypeDeclaration) {
      // Determine if the constructor itself or its container is public
      bool isPublicContext = false;

      // Get the PARENT declaration's name TOKEN
      Token? parentNameToken;
      if (parentDeclaration is ClassDeclaration) {
        parentNameToken = parentDeclaration.name;
      } else if (parentDeclaration is MixinDeclaration) {
        parentNameToken = parentDeclaration.name;
      } else if (parentDeclaration is EnumDeclaration) {
        parentNameToken = parentDeclaration.name;
      } else if (parentDeclaration is ExtensionTypeDeclaration) {
        parentNameToken = parentDeclaration.name;
      }

      // Check if the PARENT declaration (Class, Mixin, Enum, ExtType) is public using the Token's lexeme
      if (_isPublic(parentNameToken?.lexeme)) {
        // Now check the constructor name itself (SimpleIdentifier?, also has lexeme)
        // node.name is the SimpleIdentifier? for named constructors, null for default
        if (node.name == null || _isPublic(node.name?.lexeme)) {
          isPublicContext = true;
        }
      }

      if (isPublicContext) {
        // Existing logic for writing documentation and signature
        _newLineMaybe();
        _writeDocumentation(node);
        for (final annotation in node.metadata) {
          final String annotationSource = _getSource(
            annotation.offset,
            annotation.end,
          );
          _writeln(annotationSource);
        }
        final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
        final int endOffset = node.parameters.rightParenthesis.end;
        final String signature = _getSource(startOffset, endOffset);

        // Always add semicolon for non-external constructors in API view
        if (node.externalKeyword == null) {
          _writeln("$signature;");
        } else {
          _writeln(signature); // Keep external keyword, no semicolon needed
        }
      }
    }
  }

  @override
  void visitFieldDeclaration(FieldDeclaration node) {
    // Only process if inside a relevant container (Class, Mixin, Enum, ExtType)
    if (_isMemberContainer(node.parent)) {
      // Check if *at least one* of the declared variables in this statement is public
      final variables = node.fields.variables; // Get the list of variable nodes
      final bool hasPublicField = variables.any(
        (v) => _isPublic(v.name.lexeme),
      );

      if (hasPublicField) {
        _writeDocumentation(node);
        for (final annotation in node.metadata) {
          final String annotationSource = _getSource(
            annotation.offset,
            annotation.end,
          );
          _writeln(annotationSource);
        }
        // Check modifiers
        final bool isStatic = node.isStatic;
        final VariableDeclarationList fieldList = node.fields;
        final bool isConst = fieldList.keyword?.type == Keyword.CONST;
        final bool isFinal = fieldList.keyword?.type == Keyword.FINAL;

        // --- LATE CHECK ---
        // Check if the token *before* the main keyword (or type if no keyword) is 'late'
        // This is heuristic - assumes 'late' comes right before 'final'/'var'/type
        Token? tokenBeforeKeywordOrType = fieldList.keyword?.previous //
            ??
            fieldList.type?.beginToken.previous;
        final bool isLate = tokenBeforeKeywordOrType?.type == Keyword.LATE;

        // Special handling for static const
        if (isStatic && isConst) {
          final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
          final int endOffset = node.semicolon.end;
          final String signature = _getSource(startOffset, endOffset);
          _writeln(signature);
        } else {
          // Build signature manually for other fields
          final buffer = StringBuffer();

          // Add modifiers in canonical order
          if (isLate) buffer.write('late ');
          if (isFinal) buffer.write('final ');
          // isConst only relevant if static (handled above)
          if (isStatic) buffer.write('static ');

          // Type annotation
          final typeAnnotation = fieldList.type;
          if (typeAnnotation != null) {
            buffer.write(
              '${_getSource(typeAnnotation.offset, typeAnnotation.end)} ',
            );
          } else if (fieldList.keyword?.type == Keyword.VAR) {
            // Keep 'var' if explicitly used and no type
            buffer.write('var ');
          }

          // Public Variable names
          bool firstPublicVarWritten = true;
          for (var variable in variables) {
            if (_isPublic(variable.name.lexeme)) {
              if (!firstPublicVarWritten) buffer.write(', ');
              buffer.write(variable.name.lexeme);
              firstPublicVarWritten = false;
            }
          }

          // Write line only if public vars were found
          if (!firstPublicVarWritten) {
            buffer.write(';');
            _writeln(buffer.toString());
          }
        }
      }
    }
  }

  @override
  void visitTopLevelVariableDeclaration(TopLevelVariableDeclaration node) {
    if (node.parent is CompilationUnit) {
      final bool hasPublicVar = node.variables.variables.any(
        (v) => _isPublic(v.name.lexeme),
      );
      if (hasPublicVar) {
        _newLineMaybe();
        _writeDocumentation(node);
        for (final annotation in node.metadata) {
          final String annotationSource = _getSource(
            annotation.offset,
            annotation.end,
          );
          _writeln(annotationSource);
        }
        final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
        final int endOffset = node.semicolon.end;
        final String signature = _getSource(startOffset, endOffset);
        _writeln(signature);
      }
    }
  }

  @override
  void visitFunctionTypeAlias(FunctionTypeAlias node) {
    if (node.parent is CompilationUnit && _isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset = node.semicolon.end;
      final String signature = _getSource(startOffset, endOffset);
      _writeln(signature);
    }
  }

  @override
  void visitGenericTypeAlias(GenericTypeAlias node) {
    if (node.parent is CompilationUnit && _isPublic(node.name.lexeme)) {
      _newLineMaybe();
      _writeDocumentation(node);
      for (final annotation in node.metadata) {
        final String annotationSource = _getSource(
          annotation.offset,
          annotation.end,
        );
        _writeln(annotationSource);
      }
      final int startOffset = node.firstTokenAfterCommentAndMetadata.offset;
      final int endOffset = node.semicolon.end;
      final String signature = _getSource(startOffset, endOffset);
      _writeln(signature);
    }
  }

  // --- Ignore/Skip Methods ---
  // (Remain the same)
  @override
  void visitImportDirective(ImportDirective node) {}
  @override
  void visitExportDirective(ExportDirective node) {}
  @override
  void visitPartDirective(PartDirective node) {}
  @override
  void visitPartOfDirective(PartOfDirective node) {}
}

<!-- END FILE: [v0.2.2] lib/src/processing/api_extractor_visitor.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/processing/content_processor.dart -->
import '../models/enums.dart';

/// Defines the interface for processing the content of a file
/// based on the configured extraction mode.
///
/// Implementations of this interface can modify file content, for example,
/// by removing private members and implementation details for the 'api' mode,
/// or performing other transformations.
abstract class ContentProcessor {
  /// Processes the given [content] of a file at [relativePath].
  ///
  /// The processing logic depends on the specified [mode].
  ///
  /// - [relativePath]: The path of the file relative to the project root.
  ///   This can be useful for context or error reporting.
  /// - [content]: The original string content of the file.
  /// - [mode]: The [ExtractionMode] (e.g., full, api) dictating how the
  ///   content should be processed.
  ///
  /// Returns the processed string content.
  String processContent(
    String relativePath,
    String content,
    ExtractionMode mode,
  );
}

<!-- END FILE: [v0.2.2] lib/src/processing/content_processor.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/processing/dart_content_processor.dart -->
import 'dart:io';

import 'package:analyzer/dart/analysis/utilities.dart';
import 'package:analyzer/error/error.dart'; // For AnalysisError

// Local imports
import '../models/enums.dart';
import 'api_extractor_visitor.dart';
import 'content_processor.dart';

class DartContentProcessor implements ContentProcessor {
  @override
  String processContent(
    String relativePath,
    String content,
    ExtractionMode mode,
  ) {
    switch (mode) {
      case ExtractionMode.full:
        return content;

      case ExtractionMode.api:
        try {
          // Errors are accessed via the result object.
          final parseResult = parseString(
            content: content,
            path: relativePath, // Providing path is good practice
            throwIfDiagnostics: false, // Don't throw on parse errors
          );

          // Filter for actual errors, not hints/warnings if desired
          final List<AnalysisError> parseErrors = parseResult.errors //
              .where((e) => e.errorCode.errorSeverity == ErrorSeverity.ERROR)
              .toList();

          if (parseErrors.isNotEmpty) {
            stderr.writeln(
                "Warning: Could not fully parse '$relativePath' due to errors. API extraction might be incomplete "
                "or incorrect. Falling back to original content for this file.");
            // for (final error in parseErrors) {
            //   stderr.writeln("  - Error Code: ${error.errorCode.name}");
            //   stderr.writeln("  - Message: ${error.message}");
            //   stderr.writeln("  - Offset: ${error.offset}, Length: ${error.length}");
            // }
            return content;
          }

          final compilationUnit = parseResult.unit;

          final visitor = ApiExtractorVisitor(content);

          compilationUnit.accept(visitor);

          return visitor.apiOutput.toString();
        } catch (e, stackTrace) {
          stderr.writeln("Error processing API for '$relativePath': $e");
          stderr.writeln(stackTrace);

          return content;
        }
    }
  }
}

// Removed _SilentErrorListener as it's no longer needed here

<!-- END FILE: [v0.2.2] lib/src/processing/dart_content_processor.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/processing/project_processor.dart -->
import 'dart:io';

import 'package:yaml/yaml.dart';

// Local imports
import '../config/configuration.dart';
import '../core/file_ordering_strategy.dart';
import '../models/file_entry.dart';
import '../models/project_context.dart';
import 'content_processor.dart';
import 'dart_content_processor.dart';

/// Processes the raw list of file entries based on the configuration.
///
/// This involves:
/// - Processing file content using appropriate [ContentProcessor]s.
/// - Extracting project metadata (e.g., package name, version from pubspec.yaml).
/// - Sorting the files using [FileOrderingStrategy].
/// - Returning a [ProjectContext] containing processed and sorted files and metadata.
class ProjectProcessor {
  final Configuration _config;
  final ContentProcessor _dartProcessor;
  final FileOrderingStrategy _orderingStrategy;

  // Add other processors here if needed for other file types later

  /// Creates a [ProjectProcessor].
  ///
  /// Requires the final [Configuration]. Initializes content processors and
  /// the file ordering strategy.
  ProjectProcessor(this._config)
      : _dartProcessor = DartContentProcessor(),
        _orderingStrategy = FileOrderingStrategy(_config) {
    // <-- Initialize strategy
    // Initialize other processors if necessary
    if (_config.verbose) {
      print('ProjectProcessor initialized.');
    }
  }

  /// Processes the raw file list, extracts metadata, and sorts the files.
  ///
  /// - [rawFiles]: The list of [FileEntry] objects directly from [FileExtractor].
  ///
  /// Returns a [ProjectContext] with processed and sorted data.
  ProjectContext process(List<FileEntry> rawFiles) {
    if (_config.verbose) {
      print('Starting project processing...');
      print('Received ${rawFiles.length} raw files from extractor.');
    }

    // 1. Process file content and collect processed entries
    final List<FileEntry> processedFiles = [];
    String? packageName;
    String? packageVersion;
    FileEntry? pubspecEntry;

    for (final entry in rawFiles) {
      if (entry.relativePath == 'pubspec.yaml') {
        pubspecEntry = entry;
        // Extract info later, but add the file to processed list now
        // Assuming pubspec content doesn't need 'processing' via ContentProcessor
        processedFiles.add(entry);
        continue;
      }
      // Process other files using the appropriate content processor
      processedFiles.add(_processSingleFile(entry));
    }

    // 2. Extract metadata from pubspec.yaml if found
    if (pubspecEntry != null) {
      final pubspecInfo = _extractPubspecInfo(pubspecEntry);
      packageName = pubspecInfo['name'];
      packageVersion = pubspecInfo['version'];
      if (_config.verbose) {
        print(
            'Extracted from pubspec.yaml: name=$packageName, version=$packageVersion');
      }
    } else if (_config.verbose) {
      print('pubspec.yaml not found in extracted files.');
    }

    // 3. Sort the processed files using the ordering strategy <-- NEW STEP
    if (_config.verbose) {
      print(
          'Applying file ordering strategy to ${processedFiles.length} processed files...');
    }
    final List<FileEntry> sortedFiles =
        _orderingStrategy.organizeFiles(processedFiles);
    if (_config.verbose) {
      print(
          'File ordering completed. Resulting order has ${sortedFiles.length} files.');
      // Optional: Print the sorted file names for debugging
      // sortedFiles.forEach((f) => print('  - ${f.relativePath}'));
    }

    if (_config.verbose) {
      print('Project processing finished.');
    }

    // 4. Create and return the context with the sorted files <-- UPDATED STEP
    return ProjectContext(
      type: _config.projectType,
      packageName: packageName,
      packageVersion: packageVersion,
      files: sortedFiles, // <-- Use the sorted list here
      extractionTime: DateTime.now(), // Record the time processing finished
    );
  }

  /// Processes the content of a single file entry based on its type and config mode.
  /// Preserves the original metadata.
  FileEntry _processSingleFile(FileEntry entry) {
    // Determine if it's a Dart file
    if (entry.relativePath.endsWith('.dart')) {
      if (_config.verbose) {
        print(
            '  Processing Dart file content: ${entry.relativePath} (Mode: ${_config.mode.name})');
      }
      final processedContent = _dartProcessor.processContent(
        entry.relativePath,
        entry.content,
        _config.mode,
      );
      // Return a new entry with processed content if it changed,
      // making sure to pass the original metadata.
      if (processedContent != entry.content) {
        return FileEntry(
          relativePath: entry.relativePath,
          content: processedContent,
          metadata: entry.metadata,
        );
      }
    }
    // For non-Dart files or if content didn't change, return the original entry
    return entry;
  }

  /// Extracts package name and version from pubspec.yaml content.
  Map<String, String?> _extractPubspecInfo(FileEntry pubspecEntry) {
    String? name;
    String? version;
    try {
      final yamlContent = loadYaml(pubspecEntry.content);
      if (yamlContent is YamlMap) {
        final nameNode = yamlContent['name'];
        final versionNode = yamlContent['version'];
        if (nameNode is String) {
          name = nameNode;
        }
        if (versionNode is String) {
          version = versionNode;
        } else if (versionNode is num) {
          // Handle case where version might be a number (less common)
          version = versionNode.toString();
        }
      }
    } catch (e) {
      // Handle potential YAML parsing errors
      stderr.writeln("Warning: Could not parse pubspec.yaml: $e");
    }
    return {'name': name, 'version': version};
  }
}

<!-- END FILE: [v0.2.2] lib/src/processing/project_processor.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/utils/app_info.dart -->
import 'package:llmifier/src/version.dart';

/// Provides static information about the llmifier application itself.
///
/// Used primarily for generating the output file footer.
class AppInfo {
  /// The current version of the llmifier tool.
  static const String version = packageVersion; // Placeholder version

  /// The author or maintainer of the tool.
  static const String author = 'Software Engineering Philipp Gerber';

  /// The URL to the tool's repository.
  static const String repositoryUrl =
      'https://github.com/PhilippHGerber/llmifier';

  /// The URL to the tool's package page (e.g., on pub.dev).
  static const String packageUrl = 'https://pub.dev/packages/llmifier';
}

<!-- END FILE: [v0.2.2] lib/src/utils/app_info.dart -->

<!-- BEGIN FILE: [v0.2.2] lib/src/version.dart -->
// Generated code. Do not modify.
const packageVersion = '0.2.2';

<!-- END FILE: [v0.2.2] lib/src/version.dart -->

<!-- BEGIN FILE: [v0.2.2] test/processing/api_extraction_test.dart -->
import 'package:llmifier/src/models/enums.dart';
import 'package:llmifier/src/processing/dart_content_processor.dart';
import 'package:test/test.dart';

// Helper function to simplify calling the API extraction logic
String processApi(String sourceContent, {String path = 'test.dart'}) {
  final processor = DartContentProcessor();
  // Process content using API mode
  return processor.processContent(path, sourceContent, ExtractionMode.api);
}

void main() {
  group('API Extraction Tests', () {
    // =========================================================================
    // Basic Declarations Group
    // =========================================================================
    group('Basic Declarations', () {
      test('should extract public class signature without members', () {
        final input = r'''
/// A simple class.
class SimpleClass {}
''';
        // Expect class signature with braces on separate lines
        final expectedOutput = r'''
/// A simple class.
class SimpleClass {
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public top-level function signature', () {
        final input = r'''
/// Adds two numbers.
int add(int a, int b) {
  return a + b; // Implementation should be removed
}
''';
        // Expect signature ending with a semicolon and a newline
        final expectedOutput = r'''
/// Adds two numbers.
int add(int a, int b);
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public top-level getter signature (inferred type)',
          () {
        final input = r'''
/// A global configuration.
get globalConfig => 'default';
''';
        final expectedOutput = r'''
/// A global configuration.
get globalConfig;
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public top-level getter signature (explicit type)',
          () {
        final input = r'''
/// The current user's name.
String get currentUserName {
  return 'Guest';
}
''';
        final expectedOutput = r'''
/// The current user's name.
String get currentUserName;
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public top-level getter (problem file example)', () {
        final input = r'''
ShVersion get shVersion => read(shVersionRef);
''';
        final expectedOutput = r'''
ShVersion get shVersion;
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public top-level setter signature', () {
        final input = r'''
/// Sets the global theme.
set theme(String newTheme) {
  // implementation
}
''';
        final expectedOutput = r'''
/// Sets the global theme.
set theme(String newTheme);
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public top-level variable declaration', () {
        final input = r'''
/// A configuration value.
const int timeout = 1000;
''';
        // For const variables, the initializer is part of the API contract.
        final expectedOutput = r'''
/// A configuration value.
const int timeout = 1000;
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public enum declaration with constants', () {
        final input = r'''
/// Represents the state.
enum Status {
  /// Initial state.
  initial,
  /// Loading state.
  loading,
  /// Success state.
  success,
  /// Failure state.
  failure
}
''';
        // Expect enum signature and constants with commas
        final expectedOutput = r'''
/// Represents the state.
enum Status {
  /// Initial state.
  initial,
  /// Loading state.
  loading,
  /// Success state.
  success,
  /// Failure state.
  failure,
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public mixin signature', () {
        final input = r'''
/// A mixin for logging.
mixin LoggerMixin {
  void log(String message) {
    print('[LOG] $message');
  }
}
''';
        // Expect mixin signature and method signature inside
        final expectedOutput = r'''
/// A mixin for logging.
mixin LoggerMixin {
  void log(String message);
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public extension signature', () {
        final input = r'''
/// Extension on String.
extension StringUtils on String {
  /// Checks if the string is empty.
  bool isEmptyOrNull() => this == null || this.isEmpty;
}
''';
        // Expect extension signature and method signature inside
        final expectedOutput = r'''
/// Extension on String.
extension StringUtils on String {
  /// Checks if the string is empty.
  bool isEmptyOrNull();
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public extension type declaration', () {
        final input = r'''
/// An extension type for IDs.
extension type UserId(int id) {
  /// Gets the raw ID.
  int get value => id;
}
''';
        // Expect extension type signature and getter signature inside
        final expectedOutput = r'''
/// An extension type for IDs.
extension type UserId(int id) {
  /// Gets the raw ID.
  int get value;
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public function typedef', () {
        final input = r'''
/// Callback for events.
typedef void EventCallback(int eventId);
''';
        // Expect typedef signature
        final expectedOutput = r'''
/// Callback for events.
typedef void EventCallback(int eventId);
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should extract public generic typedef', () {
        final input = r'''
/// A generic result type alias.
typedef Result<T> = ({T? value, String? error});
''';
        // Expect generic typedef signature
        final expectedOutput = r'''
/// A generic result type alias.
typedef Result<T> = ({T? value, String? error});
''';
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Basic Declarations Group

    // =========================================================================
    // Visibility Group
    // =========================================================================
    group('Visibility Tests', () {
      test('should only extract public members from a class', () {
        final input = r'''
/// A class with mixed visibility.
class MixedVisibility {
  /// Public field
  final String publicField;
  final String _privateField; // Should be ignored

  /// Public constructor.
  MixedVisibility(this.publicField, this._privateField);

  /// Public named constructor.
  MixedVisibility.named(this.publicField) : _privateField = '';

  // Private constructor - should be ignored
  MixedVisibility._internal() : publicField = '', _privateField = '';

  /// Public method
  void doPublic() {}

  // Private method - should be ignored
  void _doPrivate() {}

  /// Public getter
  int get publicGetter => 1;

  // Private getter - should be ignored
  int get _privateGetter => 0;
}
''';
        // Expect only public members, including constructors
        final expectedOutput = r'''
/// A class with mixed visibility.
class MixedVisibility {
  /// Public field
  final String publicField;

  /// Public constructor.
  MixedVisibility(this.publicField, this._privateField);

  /// Public named constructor.
  MixedVisibility.named(this.publicField);

  /// Public method
  void doPublic();

  /// Public getter
  int get publicGetter;
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should produce empty output for file with only private members',
          () {
        final input = r'''
/// Library comment
library private_stuff;

// A private class
class _PrivateClass {
  int _value = 0;
  void _run() {}
}

// A private function
String _privateTopLevel() => '';
''';
        // Expect an empty string as there's no public API surface
        final expectedOutput = r'''
'''; // Empty string expected
        expect(processApi(input), equals(expectedOutput));
      });

      test(
          'should keep public function signature even if it returns private type',
          () {
        final input = r'''
        class _PrivateType {}

        /// Returns a private type instance.
        _PrivateType getPrivate() => _PrivateType();
         ''';
        // The signature is public, even if the return type isn't exported well
        final expectedOutput = r'''
/// Returns a private type instance.
_PrivateType getPrivate();
''';
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Visibility Tests group

    // =========================================================================
    // Documentation Comments Group
    // =========================================================================
    group('Documentation Comment Tests', () {
      test('should handle multi-line doc comments correctly', () {
        final input = r'''
        /// This is the first line.
        /// This is the second line.
        ///   Indented line within comment.
        void documentedFunction() {
          // implementation
        }
        ''';
        // Expect the full doc comment preserved with its formatting
        final expectedOutput = r'''
/// This is the first line.
/// This is the second line.
///   Indented line within comment.
void documentedFunction();
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle declarations without doc comments gracefully', () {
        final input = r'''
         class NoDocClass {
           int value; // No doc comment here

           NoDocClass(this.value); // No doc comment here

           void performAction() { /* No doc */ }
         }
         ''';
        // Expect signatures without preceding comments, correct spacing.
        // Visitor might add a newline before members if previous one had comment.
        final expectedOutput = r'''
class NoDocClass {
  int value;

  NoDocClass(this.value);

  void performAction();
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should preserve doc comments on enum constants', () {
        final input = r'''
          enum State {
            /// The initial state.
            initial,
            // No doc here
            loading,
            /// The final state.
            done
          }
          ''';
        final expectedOutput = r'''
enum State {
  /// The initial state.
  initial,
  loading,
  /// The final state.
  done,
}
''';
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Documentation Comment Tests group

    // =========================================================================
    // Signatures and Details Group
    // =========================================================================
    group('Signatures and Details', () {
      test('should handle various parameter types', () {
        final input = r'''
/// A function with various parameters.
void process(
  int positional,
  [String? optionalPositional, bool flag = true]
) {
  // impl
}

/// Another function with named parameters.
void configure({
  required String name,
  int? count,
  bool enabled = false
}) {
  // impl
}
''';
        // Expect signatures, default values are removed in API view
        final expectedOutput = r'''
/// A function with various parameters.
void process(
  int positional,
  [String? optionalPositional, bool flag = true]
);

/// Another function with named parameters.
void configure({
  required String name,
  int? count,
  bool enabled = false
});
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle different return types and generics', () {
        final input = r'''
           /// Async fetch.
           Future<String> fetchData<T>(T id) async => 'data';

           /// Void function.
           void doNothing() {}

           /// Generic class.
           class Repository<T extends Object> {
             /// Find by ID.
             Future<T?> findById(String id) async => null;
           }
           ''';
        final expectedOutput = r'''
/// Async fetch.
Future<String> fetchData<T>(T id);

/// Void function.
void doNothing();

/// Generic class.
class Repository<T extends Object> {
  /// Find by ID.
  Future<T?> findById(String id);
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle field modifiers', () {
        final input = r'''
           class ModifiersExample {
             final String immutable;
             static const int compileConstant = 0;
             late String initializedLater;
             String mutable;
             static String staticMutable = '';

             ModifiersExample(this.immutable, this.mutable);
           }
           ''';
        // Expect declarations keeping modifiers
        // Keep initializer for 'static const', remove for 'static String'.
        // Expect NO extra blank lines between fields or before constructor.
        final expectedOutput = r'''
class ModifiersExample {
  final String immutable;
  static const int compileConstant = 0;
  late String initializedLater;
  String mutable;
  static String staticMutable;

  ModifiersExample(this.immutable, this.mutable);
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle method modifiers (static, abstract)', () {
        final input = r'''
           abstract class ModifierMethods {
             /// Static factory method.
             static ModifierMethods create() => _Concrete();

             /// Abstract method to implement.
             void process();
           }

           class _Concrete implements ModifierMethods {
             @override
             void process() {}
           }
           ''';
        // Expect static method and abstract method signatures
        final expectedOutput = r'''
abstract class ModifierMethods {
  /// Static factory method.
  static ModifierMethods create();

  /// Abstract method to implement.
  void process();
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle getters and setters', () {
        final input = r'''
           class GetSet {
             int _value = 0;

             /// The current value.
             int get value => _value;

             /// Set a new value.
             set value(int newValue) => _value = newValue;
           }
           ''';
        // Expect getter and setter signatures
        final expectedOutput = r'''
class GetSet {
  /// The current value.
  int get value;

  /// Set a new value.
  set value(int newValue);
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test(
          'should correctly extract class method, getter, and setter signatures',
          () {
        final input = r'''
class MyService {
  /// A regular method.
  void performAction(String input) {
    // implementation
  }

  /// A getter property.
  String get status {
    return "active";
  }

  /// A setter property.
  set newStatus(String s) {
    // implementation
  }

  /// Getter with no explicit type
  get version => "1.0";

  /// Abstract method
  void mustImplement();

  /// External method
  external void nativeCall(int code);
}
''';
        final expectedOutput = r'''
class MyService {
  /// A regular method.
  void performAction(String input);

  /// A getter property.
  String get status;

  /// A setter property.
  set newStatus(String s);

  /// Getter with no explicit type
  get version;

  /// Abstract method
  void mustImplement();

  /// External method
  external void nativeCall(int code);
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle various constructor types', () {
        final input = r'''
          class Widget {
            final int id;

            /// Default constructor.
            Widget(this.id);

            /// Named constructor.
            Widget.named(this.id);

            /// Const constructor.
            const Widget.constant(this.id);

            /// Factory constructor.
            factory Widget.fromId(int id) {
              return Widget(id);
            }
          }
          ''';
        // Expect all constructor signatures
        final expectedOutput = r'''
class Widget {
  final int id;

  /// Default constructor.
  Widget(this.id);

  /// Named constructor.
  Widget.named(this.id);

  /// Const constructor.
  const Widget.constant(this.id);

  /// Factory constructor.
  factory Widget.fromId(int id);
}
''';
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Signatures and Details Group

    // =========================================================================
    // Metadata Annotations Group
    // =========================================================================
    group('Metadata Annotations', () {
      test('should preserve common annotations', () {
        final input = r'''
          class Base {
            void method() {}
          }
          class Derived extends Base {
            @override
            void method() {}

            @Deprecated('Use method() instead')
            void oldMethod() {}
          }
          ''';
        // Expect annotations to be kept with the signatures
        final expectedOutput = r'''
class Base {
  void method();
}

class Derived extends Base {
  @override
  void method();

  @Deprecated('Use method() instead')
  void oldMethod();
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should preserve multiple and custom annotations', () {
        final input = r'''
          const myAnnotation = Object();

          @myAnnotation
          @Deprecated('Old class')
          class AnnotatedClass {
            @myAnnotation
            final int field;

            AnnotatedClass(this.field);
          }
          ''';
        // Expect all annotations to be kept
        final expectedOutput = r'''
const myAnnotation = Object();

@myAnnotation
@Deprecated('Old class')
class AnnotatedClass {
  @myAnnotation
  final int field;

  AnnotatedClass(this.field);
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should preserve annotations on parameters', () {
        final input = r'''
          const Required = Object();
          void process({@Required String name}) {}
          ''';
        // Expect annotation on parameter to be kept
        final expectedOutput = r'''
const Required = Object();

void process({@Required String name});
''';
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Metadata Annotations Group

    // =========================================================================
    // Ignored Elements Group
    // =========================================================================
    group('Ignored Elements', () {
      test('should ignore directives (import, export, library, part, part of)',
          () {
        // --- CORRECTED input: Removed invalid 'part of' inside class ---
        final input = r'''
         library my_lib;

         import 'dart:async';
         import 'package:meta/meta.dart';

         export 'src/models.dart';
         part 'src/internal_utils.dart'; // Valid top-level directive

         /// This class should be kept.
         class PublicApi {
           // No 'part of' here anymore
           /// A field inside the class.
           int value = 0;
         }

         /// This function should be kept.
         void publicFunction() {}
         ''';

        // Expected output should now be generated correctly without directives
        final expectedOutput = r'''
/// This class should be kept.
class PublicApi {
  /// A field inside the class.
  int value;
}

/// This function should be kept.
void publicFunction();
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should ignore non-doc comments', () {
        final input = r'''
         // This is a single line comment before class.
         /* This is a
            block comment before class. */
         class MyClass {
           // Comment inside class
           int field; /* block comment */

           /* Comment before method */
           void method() {
             // Implementation comment
           }
         }
         ''';
        // Expect only the class structure and public signature, no regular comments
        final expectedOutput = r'''
class MyClass {
  int field;

  void method();
}
''';
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Ignored Elements Group

    // =========================================================================
    // Formatting Group
    // =========================================================================
    group('Formatting', () {
      test('should maintain reasonable spacing between top-level elements', () {
        final input = r'''
         /// First function.
         void func1() {}


         /// Second function.
         void func2() {} // Extra space before this class

         class MyClass {
           /// Method 1.
           void method1() {}


           /// Method 2.
           void method2() {}
         }
         ''';
        // Expect consistent (single) newline spacing controlled by the visitor
        final expectedOutput = r'''
/// First function.
void func1();

/// Second function.
void func2();

class MyClass {
  /// Method 1.
  void method1();

  /// Method 2.
  void method2();
}
''';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle indentation correctly within declarations', () {
        // --- REVISED input using valid Dart ---
        // Replace nested class with methods and fields
        final input = r'''
         class Outer {
           int outerField;

           /// An inner method.
           void innerMethod(int value) {
              // Some implementation
           }

           /// Another outer method.
           String outerMethod() {
             return 'result';
           }
         } // End Outer
         ''';

        // --- REVISED expectedOutput based on valid input ---
        final expectedOutput = r'''
class Outer {
  int outerField;

  /// An inner method.
  void innerMethod(int value);

  /// Another outer method.
  String outerMethod();
}
''';
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Formatting Group

    // =========================================================================
    // Error Handling Group (DartContentProcessor)
    // =========================================================================
    group('Error Handling (DartContentProcessor)', () {
      test('should return original content on parse error', () {
        // Input with a clear syntax error (missing closing brace)
        final inputWithError = r'''
class MyClass {
  void myMethod() { // Missing closing brace
''';
        // Expect the *original* content back due to the parse error fallback
        expect(processApi(inputWithError), equals(inputWithError));
        // Optionally, check stderr output if logging is implemented and testable
      });

      test('should handle empty input string', () {
        final input = '';
        final expectedOutput = '';
        expect(processApi(input), equals(expectedOutput));
      });

      test('should handle input with only comments and directives', () {
        final input = r'''
// This is a line comment
/* This is a block comment */
/// This is a doc comment, but no declaration follows
library test_lib; // Now before import

import 'dart:io'; // Import after library
''';
        // Expect an empty string as there's no API surface
        final expectedOutput = r'''
'''; // Empty string expected
        expect(processApi(input), equals(expectedOutput));
      });
    }); // End of Error Handling Group
  }); // End of API Extraction Tests group
}

<!-- END FILE: [v0.2.2] test/processing/api_extraction_test.dart -->

---
Generated with llmifier v0.2.2
Created by Software Engineering Philipp Gerber
Repository: https://github.com/PhilippHGerber/llmifier
Package: https://pub.dev/packages/llmifier
